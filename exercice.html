<!DOCTYPE html>
<html lang="fr">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ArduinoLearn - Exercices Pratiques</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    :root {
      --primary-color: #00979c;
      --secondary-color: #00696b;
      --accent-color: #ff9800;
      --light-color: #f8f9fa;
      --dark-color: #333;
      --gray-color: #6c757d;
      --code-bg: #f4f4f4;
      --success-color: #28a745;
      --warning-color: #ffc107;
      --danger-color: #dc3545;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    body {
      background-color: #f5f5f5;
      color: var(--dark-color);
      line-height: 1.6;
    }

    .container {
      width: 100%;
      margin: 0 auto;
      padding: 0 20px;
    }

    /* Header */
    header {
      background-color: var(--primary-color);
      color: white;
      padding: 1rem 0;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      position: sticky;
      top: 0;
      z-index: 100;
    }

    .header-content {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .logo {
      font-size: 1.8rem;
      font-weight: 700;
      display: flex;
      align-items: center;
    }

    .logo i {
      margin-right: 10px;
      color: var(--accent-color);
    }

    .logo span {
      color: var(--accent-color);
    }

    nav ul {
      display: flex;
      list-style: none;
    }

    nav ul li {
      margin-left: 1.5rem;
    }

    nav ul li a {
      color: white;
      text-decoration: none;
      font-weight: 500;
      transition: color 0.3s;
      padding: 5px 10px;
      border-radius: 4px;
    }

    nav ul li a:hover {
      color: var(--accent-color);
      background-color: rgba(255, 255, 255, 0.1);
    }

    /* Hero Section */
    .hero {
      background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
      color: white;
      padding: 3rem 0;
      text-align: center;
      margin-bottom: 2rem;
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      transition: background-image 1s ease-in-out;
    }

    .hero h1 {
      font-size: 2.5rem;
      margin-bottom: 1rem;
    }

    .hero p {
      font-size: 1.1rem;
      max-width: 800px;
      margin: 0 auto 1.5rem;
      opacity: 0.9;
    }

    /* Main Content */
    .main-content {
      display: flex;
      flex-direction: column;
      gap: 2rem;
      margin-bottom: 3rem;
    }

    /* Exercise Grid */
    .exercise-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
      gap: 2rem;
      margin: 2rem 0;
    }

    .exercise-card {
      background-color: white;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 6px 15px rgba(0, 0, 0, 0.1);
      transition: transform 0.3s, box-shadow 0.3s;
      border: 2px solid transparent;
    }

    .exercise-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 12px 25px rgba(0, 0, 0, 0.15);
    }

    .exercise-header {
      background-color: var(--primary-color);
      color: white;
      padding: 1.2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .exercise-header h3 {
      margin: 0;
      font-size: 1.3rem;
    }

    .exercise-difficulty {
      padding: 0.3rem 1rem;
      border-radius: 20px;
      font-size: 0.85rem;
      font-weight: 600;
      text-transform: uppercase;
    }

    .difficulty-beginner {
      background-color: var(--success-color);
    }

    .difficulty-intermediate {
      background-color: var(--warning-color);
      color: var(--dark-color);
    }

    .difficulty-advanced {
      background-color: var(--danger-color);
    }

    .exercise-body {
      padding: 1.5rem;
    }

    .exercise-description {
      margin-bottom: 1.5rem;
      color: var(--dark-color);
    }

    .exercise-objectives {
      background-color: #f8f9fa;
      padding: 1rem;
      border-radius: 8px;
      margin-bottom: 1.5rem;
      border-left: 4px solid var(--primary-color);
    }

    .exercise-objectives h4 {
      color: var(--primary-color);
      margin-bottom: 0.5rem;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .exercise-objectives ul {
      padding-left: 1.5rem;
      margin-bottom: 0;
    }

    .exercise-objectives li {
      margin-bottom: 0.3rem;
    }

    /* Exercise Workspace */
    .exercise-workspace {
      background-color: white;
      border-radius: 12px;
      padding: 2rem;
      box-shadow: 0 6px 15px rgba(0, 0, 0, 0.1);
      margin-bottom: 2rem;
    }

    .workspace-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1.5rem;
      padding-bottom: 1rem;
      border-bottom: 2px solid #eee;
    }

    .workspace-title {
      color: var(--primary-color);
      font-size: 1.5rem;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    /* Workspace Layout */
    .workspace-layout {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 2rem;
      margin-top: 1.5rem;
    }

    @media (max-width: 992px) {
      .workspace-layout {
        grid-template-columns: 1fr;
      }
    }

    /* Code Editor */
    .code-workspace {
      background-color: #f8f9fa;
      border-radius: 10px;
      overflow: hidden;
      border: 1px solid #ddd;
    }

    .code-header {
      background-color: #2d2d2d;
      padding: 0.8rem 1.2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .code-title {
      color: #aaa;
      font-family: monospace;
      font-size: 0.95rem;
    }

    .editor-dots {
      display: flex;
      gap: 6px;
    }

    .editor-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
    }

    .editor-dot.red {
      background-color: #ff5f56;
    }

    .editor-dot.yellow {
      background-color: #ffbd2e;
    }

    .editor-dot.green {
      background-color: #27ca3f;
    }

    .code-area {
      padding: 1.5rem;
      min-height: 400px;
      max-height: 500px;
      overflow-y: auto;
      font-family: 'Courier New', monospace;
      font-size: 0.95rem;
      line-height: 1.5;
      color: #333;
      white-space: pre-wrap;
      tab-size: 2;
      background-color: #fefefe;
    }

    .code-line {
      padding: 2px 0;
      min-height: 20px;
    }

    .code-line:hover {
      background-color: #f0f0f0;
    }

    .line-number {
      display: inline-block;
      width: 40px;
      color: #999;
      text-align: right;
      padding-right: 10px;
      user-select: none;
    }

    .code-input {
      background: transparent;
      border: none;
      outline: none;
      font-family: 'Courier New', monospace;
      font-size: 0.95rem;
      width: calc(100% - 50px);
      color: #333;
    }

    .code-input:focus {
      background-color: #e8f4ff;
    }

    .code-comment {
      color: #6a9955;
    }

    .code-keyword {
      color: #569cd6;
      font-weight: bold;
    }

    .code-function {
      color: #dcdcaa;
    }

    .code-value {
      color: #ce9178;
    }

    .code-string {
      color: #ce9178;
    }

    .code-number {
      color: #b5cea8;
    }

    .code-preprocessor {
      color: #c586c0;
    }

    .code-type {
      color: #4ec9b0;
    }

    /* Simulation Area */
    .simulation-area {
      background-color: #f8f9fa;
      border-radius: 10px;
      padding: 1.5rem;
      border: 1px solid #ddd;
      min-height: 500px;
      display: flex;
      flex-direction: column;
    }

    .simulation-title {
      color: var(--secondary-color);
      margin-bottom: 1.5rem;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    /* ESP32 Board Simulation */
    .esp32-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2rem;
      margin-top: 1rem;
    }

    .esp32-board {
      height: 250px;
      background-color: #1e3799;
      border-radius: 12px;
      position: relative;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
      border: 4px solid #0c2461;
    }

    .esp32-chip {
      position: absolute;
      top: 40px;
      left: 50%;
      transform: translateX(-50%);
      width: 120px;
      height: 80px;
      background-color: #222;
      border-radius: 8px;
      color: white;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 1rem;
      font-weight: bold;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
    }

    .esp32-antenna {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background-color: #333;
      display: flex;
      justify-content: center;
      align-items: center;
      color: #ffd32a;
      box-shadow: 0 0 8px rgba(255, 211, 42, 0.5);
    }

    /* Pins Grid */
    .pins-grid {
        display: grid;
        grid-template-columns: repeat(10, 1fr);
        gap: 8px;
        margin: 28px;
        padding: 37px;
        background-color: rgba(0, 0, 0, 0.2);
        border-radius: 8px;
      }

    .pin {
      width: 35px;
      height: 60px;
      background-color: #d1d8e0;
      border-radius: 4px;
      position: relative;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .pin:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }

    .pin.active {
      background-color: #ffd32a;
      box-shadow: 0 0 10px #ffd32a;
    }

    .pin.input {
      background-color: #4cd137;
    }

    .pin.output {
      background-color: #e84118;
    }

    .pin.pwm {
      background-color: #8c7ae6;
    }

    .pin-label {
      position: absolute;
      top: -25px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.7rem;
      color: white;
      font-weight: bold;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
      white-space: nowrap;
    }

    .pin-status {
      position: absolute;
      bottom: -20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.6rem;
      color: white;
      font-weight: bold;
    }

    /* LEDs Container */
    .leds-container {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 2rem;
      margin-top: 1rem;
      padding: 1.5rem;
      background-color: rgba(0, 0, 0, 0.05);
      border-radius: 10px;
    }

    .led {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background-color: #ccc;
      box-shadow: 0 0 15px rgba(0, 0, 0, 0.3);
      position: relative;
      transition: all 0.3s;
    }

    .led.on {
      box-shadow: 0 0 25px currentColor;
    }

    .led-red.on {
      background-color: #ff3838;
      color: #ff3838;
    }

    .led-green.on {
      background-color: #32ff7e;
      color: #32ff7e;
    }

    .led-blue.on {
      background-color: #18dcff;
      color: #18dcff;
    }

    .led-yellow.on {
      background-color: #ffaf40;
      color: #ffaf40;
    }

    .led-label {
      position: absolute;
      bottom: -30px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.9rem;
      font-weight: 600;
      color: var(--dark-color);
      white-space: nowrap;
    }

    .led-connected-pin {
      position: absolute;
      top: -25px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.8rem;
      color: var(--primary-color);
      font-weight: bold;
    }

    /* Controls */
    .workspace-controls {
      display: flex;
      gap: 1rem;
      margin-top: 2rem;
      flex-wrap: wrap;
    }

    .control-btn {
      padding: 0.7rem 1.5rem;
      background-color: var(--primary-color);
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.3s;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.95rem;
    }

    .control-btn:hover {
      background-color: var(--secondary-color);
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }

    .control-btn.run {
      background-color: var(--success-color);
    }

    .control-btn.run:hover {
      background-color: #218838;
    }

    .control-btn.reset {
      background-color: var(--gray-color);
    }

    .control-btn.reset:hover {
      background-color: #5a6268;
    }

    .control-btn.check {
      background-color: var(--accent-color);
    }

    .control-btn.check:hover {
      background-color: #e68900;
    }

    /* Feedback Area */
    .feedback-area {
      margin-top: 2rem;
      padding: 1.5rem;
      border-radius: 10px;
      background-color: #f8f9fa;
      border: 1px solid #ddd;
      display: none;
    }

    .feedback-area.show {
      display: block;
      animation: fadeIn 0.5s;
    }

    .feedback-header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 1rem;
      padding-bottom: 0.8rem;
      border-bottom: 2px solid #eee;
    }

    .feedback-title {
      font-size: 1.2rem;
      color: var(--primary-color);
    }

    .feedback-content {
      line-height: 1.6;
    }

    .feedback-success {
      color: var(--success-color);
      font-weight: bold;
    }

    .feedback-error {
      color: var(--danger-color);
      font-weight: bold;
    }

    .feedback-hint {
      background-color: #fff3cd;
      border-left: 4px solid var(--warning-color);
      padding: 1rem;
      margin: 1rem 0;
      border-radius: 4px;
    }

    .feedback-hint h5 {
      color: var(--warning-color);
      margin-bottom: 0.5rem;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    /* Serial Monitor */
    .serial-monitor {
      background-color: #000;
      color: #00ff00;
      font-family: 'Courier New', monospace;
      padding: 1rem;
      border-radius: 6px;
      height: 200px;
      overflow-y: auto;
      margin-top: 1.5rem;
      border: 2px solid #444;
    }

    .serial-line {
      margin-bottom: 0.5rem;
      font-size: 0.9rem;
    }

    /* Instructions */
    .instructions {
      background-color: #e9f7f7;
      padding: 1.5rem;
      border-radius: 10px;
      margin-bottom: 2rem;
      border-left: 5px solid var(--primary-color);
    }

    .instructions h3 {
      color: var(--primary-color);
      margin-bottom: 1rem;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .instructions ul {
      padding-left: 1.5rem;
      margin-bottom: 1rem;
    }

    .instructions li {
      margin-bottom: 0.5rem;
    }

    /* Progress Bar */
    .progress-container {
      margin: 2rem 0;
      background-color: #e9ecef;
      border-radius: 10px;
      overflow: hidden;
      height: 12px;
    }

    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
      width: 0%;
      transition: width 0.5s ease;
    }

    /* Responsive */
    @media (max-width: 768px) {
      .header-content {
        flex-direction: column;
        text-align: center;
      }

      nav ul {
        margin-top: 1rem;
        justify-content: center;
        flex-wrap: wrap;
      }

      nav ul li {
        margin: 0.3rem 0.5rem;
      }

      .esp32-board {
        width: 320px;
        height: 200px;
      }

      .pin {
        width: 25px;
        height: 45px;
      }

      .pin-label {
        font-size: 0.6rem;
        top: -20px;
      }

      .exercise-grid {
        grid-template-columns: 1fr;
      }

      .workspace-controls {
        justify-content: center;
      }
    }

    /* Animations */
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes blink {

      0%,
      100% {
        opacity: 1;
      }

      50% {
        opacity: 0.3;
      }
    }

    .blink {
      animation: blink 1s infinite;
    }

    .fade-in {
      animation: fadeIn 0.5s ease-out;
    }

    /* Active states */
    .active {
      color: var(--accent-color);
    }
    .code-display {
        display: inline;
        cursor: text;
        padding: 2px 4px;
        border-radius: 3px;
        min-height: 20px;
        min-width: 10px;
      }
      
      .code-display:hover {
        background-color: #f0f0f0;
      }
      
      .code-input {
        background: transparent;
        border: none;
        outline: none;
        font-family: 'Courier New', monospace;
        font-size: 0.95rem;
        width: calc(100% - 50px);
        color: #333;
        padding: 2px 4px;
        border-radius: 3px;
        border: 1px solid #ddd;
      }
      
      .code-input:focus {
        background-color: #e8f4ff;
        border-color: #4dabf7;
      }
  </style>
</head>

<body>
  <!-- Header -->
  <header>
    <div class="container header-content">
      <div class="logo">
        <i class="fas fa-microchip"></i>
        <div><span></span> Arduino/ESP <span>Learn</span></div>
      </div>
      <nav>
        <ul>
          <li><a href="index.html"><i class="fas fa-home"></i> Accueil</a></li>
          <!-- <li><a href="./pratique.html"><i class="fas fa-graduation-cap"></i> pratique</a></li> -->
          <li><a href="./exemple.html"><i class="fas fa-code"></i> Exemples</a></li>
          <li><a href="./reference.html"><i class="fas fa-book"></i> Référence</a></li>
          <li><a href="exercice.html" class="active"><i class="fas fa-pencil-alt"></i> Exercices</a></li>
        </ul>
      </nav>
    </div>
  </header>

  <!-- Hero Section -->
  <section class="hero">
    <div class="container">
      <h1>Exercices Pratiques Arduino/ESP</h1>
      <p>Testez vos connaissances avec des exercices interactifs et recevez une correction instantanée</p>
      <div style="display: flex; gap: 15px; justify-content: center; margin-top: 1.5rem;">
        <div style="background-color: rgba(255,255,255,0.2); padding: 0.5rem 1rem; border-radius: 20px;">
          <i class="fas fa-check-circle" style="margin-right: 8px;"></i>Correction automatique
        </div>
        <div style="background-color: rgba(255,255,255,0.2); padding: 0.5rem 1rem; border-radius: 20px;">
          <i class="fas fa-bolt" style="margin-right: 8px;"></i>Simulation en temps réel
        </div>
        <div style="background-color: rgba(255,255,255,0.2); padding: 0.5rem 1rem; border-radius: 20px;">
          <i class="fas fa-lightbulb" style="margin-right: 8px;"></i>Indices disponibles
        </div>
      </div>
    </div>
  </section>

  <!-- Main Content -->
  <div class="container main-content">
    <!-- Instructions -->
    <div class="instructions fade-in">
      <h3><i class="fas fa-info-circle"></i> Comment utiliser les exercices</h3>
      <ul>
        <li>Sélectionnez un exercice dans la liste ci-dessous</li>
        <li>Modifiez le code dans l'éditeur pour résoudre l'exercice</li>
        <li>Configurez les broches (pins) ESP32 en cliquant dessus</li>
        <li>Cliquez sur "Exécuter" pour tester votre solution</li>
        <li>Utilisez "Vérifier la solution" pour obtenir une correction automatique</li>
        <li>Consultez les indices si vous avez besoin d'aide</li>
      </ul>
      <p style="font-weight: bold; color: var(--primary-color);">
        <i class="fas fa-trophy"></i> Votre progression: <span id="progress-text">0/6 exercices complétés</span>
      </p>
      <div class="progress-container">
        <div class="progress-bar" id="progress-bar"></div>
      </div>
    </div>

    <!-- Exercise Selection Grid -->
    <div class="exercise-grid" id="exercise-grid">
      <!-- Exercise 1 -->
      <div class="exercise-card" onclick="loadExercise(1)">
        <div class="exercise-header">
          <h3>LED Clignotante</h3>
          <span class="exercise-difficulty difficulty-beginner">Débutant</span>
        </div>
        <div class="exercise-body">
          <div class="exercise-description">
            <p>Programmez une LED pour qu'elle clignote à intervalle régulier.</p>
          </div>
          <div class="exercise-objectives">
            <h4><i class="fas fa-bullseye"></i> Objectifs</h4>
            <ul>
              <li>Utiliser la fonction delay()</li>
              <li>Contrôler une sortie numérique</li>
              <li>Comprendre le cycle setup/loop</li>
            </ul>
          </div>
          <div style="display: flex; justify-content: space-between; align-items: center;">
            <span id="status-1" style="color: #6c757d;"><i class="far fa-circle"></i> Non tenté</span>
            <span style="font-size: 0.9rem;"><i class="fas fa-clock"></i> ~10 min</span>
          </div>
        </div>
      </div>

      <!-- Exercise 2 -->
      <div class="exercise-card" onclick="loadExercise(2)">
        <div class="exercise-header">
          <h3>Séquence LED Chassée</h3>
          <span class="exercise-difficulty difficulty-intermediate">Intermédiaire</span>
        </div>
        <div class="exercise-body">
          <div class="exercise-description">
            <p>Créez un effet de lumière chassée avec 4 LEDs.</p>
          </div>
          <div class="exercise-objectives">
            <h4><i class="fas fa-bullseye"></i> Objectifs</h4>
            <ul>
              <li>Contrôler plusieurs sorties</li>
              <li>Créer des séquences temporelles</li>
              <li>Utiliser des tableaux pour les broches</li>
            </ul>
          </div>
          <div style="display: flex; justify-content: space-between; align-items: center;">
            <span id="status-2" style="color: #6c757d;"><i class="far fa-circle"></i> Non tenté</span>
            <span style="font-size: 0.9rem;"><i class="fas fa-clock"></i> ~15 min</span>
          </div>
        </div>
      </div>

      <!-- Exercise 3 -->
      <div class="exercise-card" onclick="loadExercise(3)">
        <div class="exercise-header">
          <h3>Contrôle PWM (Effet respiration)</h3>
          <span class="exercise-difficulty difficulty-intermediate">Intermédiaire</span>
        </div>
        <div class="exercise-body">
          <div class="exercise-description">
            <p>Créez un effet de respiration avec modulation PWM.</p>
          </div>
          <div class="exercise-objectives">
            <h4><i class="fas fa-bullseye"></i> Objectifs</h4>
            <ul>
              <li>Utiliser les broches PWM</li>
              <li>Contrôler la luminosité d'une LED</li>
              <li>Implémenter un effet de fondu</li>
            </ul>
          </div>
          <div style="display: flex; justify-content: space-between; align-items: center;">
            <span id="status-3" style="color: #6c757d;"><i class="far fa-circle"></i> Non tenté</span>
            <span style="font-size: 0.9rem;"><i class="fas fa-clock"></i> ~20 min</span>
          </div>
        </div>
      </div>

      <!-- Exercise 4 -->
      <div class="exercise-card" onclick="loadExercise(4)">
        <div class="exercise-header">
          <h3>LED RGB - Contrôle des couleurs</h3>
          <span class="exercise-difficulty difficulty-intermediate">Intermédiaire</span>
        </div>
        <div class="exercise-body">
          <div class="exercise-description">
            <p>Contrôlez une LED RGB pour afficher différentes couleurs.</p>
          </div>
          <div class="exercise-objectives">
            <h4><i class="fas fa-bullseye"></i> Objectifs</h4>
            <ul>
              <li>Contrôler 3 broches PWM simultanément</li>
              <li>Créer et utiliser des fonctions</li>
              <li>Générer des couleurs RGB</li>
            </ul>
          </div>
          <div style="display: flex; justify-content: space-between; align-items: center;">
            <span id="status-4" style="color: #6c757d;"><i class="far fa-circle"></i> Non tenté</span>
            <span style="font-size: 0.9rem;"><i class="fas fa-clock"></i> ~25 min</span>
          </div>
        </div>
      </div>

      <!-- Exercise 5 -->
      <div class="exercise-card" onclick="loadExercise(5)">
        <div class="exercise-header">
          <h3>Feu tricolore</h3>
          <span class="exercise-difficulty difficulty-advanced">Avancé</span>
        </div>
        <div class="exercise-body">
          <div class="exercise-description">
            <p>Simulez un feu de circulation avec séquence précise.</p>
          </div>
          <div class="exercise-objectives">
            <h4><i class="fas fa-bullseye"></i> Objectifs</h4>
            <ul>
              <li>Coordonner plusieurs LEDs</li>
              <li>Implémenter des temporisations complexes</li>
              <li>Utiliser millis() pour un timing précis</li>
            </ul>
          </div>
          <div style="display: flex; justify-content: space-between; align-items: center;">
            <span id="status-5" style="color: #6c757d;"><i class="far fa-circle"></i> Non tenté</span>
            <span style="font-size: 0.9rem;"><i class="fas fa-clock"></i> ~30 min</span>
          </div>
        </div>
      </div>

      <!-- Exercise 6 -->
      <div class="exercise-card" onclick="loadExercise(6)">
        <div class="exercise-header">
          <h3>Animation Lumineuse Complexe</h3>
          <span class="exercise-difficulty difficulty-advanced">Avancé</span>
        </div>
        <div class="exercise-body">
          <div class="exercise-description">
            <p>Créez une animation complexe avec 6 LEDs et effets variés.</p>
          </div>
          <div class="exercise-objectives">
            <h4><i class="fas fa-bullseye"></i> Objectifs</h4>
            <ul>
              <li>Gérer plusieurs patterns d'animation</li>
              <li>Utiliser des structures de contrôle avancées</li>
              <li>Optimiser le code pour fluidité</li>
            </ul>
          </div>
          <div style="display: flex; justify-content: space-between; align-items: center;">
            <span id="status-6" style="color: #6c757d;"><i class="far fa-circle"></i> Non tenté</span>
            <span style="font-size: 0.9rem;"><i class="fas fa-clock"></i> ~40 min</span>
          </div>
        </div>
      </div>
      <!-- Exercice 7 -->
<div class="exercise-card" onclick="loadExercise(7)">
    <div class="exercise-header">
      <h3>LED avec bouton</h3>
      <span class="exercise-difficulty difficulty-beginner">Normal</span>
    </div>
    <div class="exercise-body">
      <div class="exercise-description">
        <p>Allumez une LED lorsque vous appuyez sur un bouton.</p>
      </div>
      <div class="exercise-objectives">
        <h4><i class="fas fa-bullseye"></i> Objectifs</h4>
        <ul>
          <li>Lire l'état d'une entrée numérique</li>
          <li>Utiliser digitalRead()</li>
          <li>Récupérer l'état d'un bouton</li>
        </ul>
      </div>
      <div style="display: flex; justify-content: space-between; align-items: center;">
        <span id="status-7" style="color: #6c757d;"><i class="far fa-circle"></i> Non tenté</span>
        <span style="font-size: 0.9rem;"><i class="fas fa-clock"></i> ~15 min</span>
      </div>
    </div>
  </div>
  
  <!-- Exercice 8 -->
  <div class="exercise-card" onclick="loadExercise(8)">
    <div class="exercise-header">
      <h3>Clignotement avec potentiomètre</h3>
      <span class="exercise-difficulty difficulty-beginner">Normal</span>
    </div>
    <div class="exercise-body">
      <div class="exercise-description">
        <p>Contrôlez la vitesse de clignotement avec un potentiomètre.</p>
      </div>
      <div class="exercise-objectives">
        <h4><i class="fas fa-bullseye"></i> Objectifs</h4>
        <ul>
          <li>Lire une entrée analogique</li>
          <li>Utiliser analogRead()</li>
          <li>Mapper des valeurs</li>
        </ul>
      </div>
      <div style="display: flex; justify-content: space-between; align-items: center;">
        <span id="status-8" style="color: #6c757d;"><i class="far fa-circle"></i> Non tenté</span>
        <span style="font-size: 0.9rem;"><i class="fas fa-clock"></i> ~20 min</span>
      </div>
    </div>
  </div>
  
  <!-- Exercice 9 -->
  <div class="exercise-card" onclick="loadExercise(9)">
    <div class="exercise-header">
      <h3>Contrôle LED avec 2 boutons</h3>
      <span class="exercise-difficulty difficulty-intermediate">Normal</span>
    </div>
    <div class="exercise-body">
      <div class="exercise-description">
        <p>Augmentez et diminuez la luminosité avec deux boutons.</p>
      </div>
      <div class="exercise-objectives">
        <h4><i class="fas fa-bullseye"></i> Objectifs</h4>
        <ul>
          <li>Gérer plusieurs entrées</li>
          <li>Implémenter un compteur</li>
          <li>Limiter les valeurs</li>
        </ul>
      </div>
      <div style="display: flex; justify-content: space-between; align-items: center;">
        <span id="status-9" style="color: #6c757d;"><i class="far fa-circle"></i> Non tenté</span>
        <span style="font-size: 0.9rem;"><i class="fas fa-clock"></i> ~25 min</span>
      </div>
    </div>
  </div>
  
  <!-- Exercice 10 -->
  <div class="exercise-card" onclick="loadExercise(10)">
    <div class="exercise-header">
      <h3>Séquence avec interruption</h3>
      <span class="exercise-difficulty difficulty-intermediate">Normal</span>
    </div>
    <div class="exercise-body">
      <div class="exercise-description">
        <p>Changez la séquence LED avec un bouton par interruption.</p>
      </div>
      <div class="exercise-objectives">
        <h4><i class="fas fa-bullseye"></i> Objectifs</h4>
        <ul>
          <li>Utiliser les interruptions</li>
          <li>Changer de mode dynamiquement</li>
          <li>Gérer les variables volatiles</li>
        </ul>
      </div>
      <div style="display: flex; justify-content: space-between; align-items: center;">
        <span id="status-10" style="color: #6c757d;"><i class="far fa-circle"></i> Non tenté</span>
        <span style="font-size: 0.9rem;"><i class="fas fa-clock"></i> ~30 min</span>
      </div>
    </div>
  </div>
    </div>

    <!-- Exercise Workspace (initially hidden) -->
    <div class="exercise-workspace" id="exercise-workspace" style="display: none;">
      <div class="workspace-header">
        <div class="workspace-title">
          <i class="fas fa-code"></i>
          <span id="workspace-title">Exercice #1: LED Clignotante</span>
        </div>
        <div style="display: flex; gap: 10px;">
          <button class="control-btn" onclick="showHint()">
            <i class="fas fa-lightbulb"></i> Indice
          </button>
          <button class="control-btn" onclick="showSolution()">
            <i class="fas fa-eye"></i> Solution
          </button>
          <button class="control-btn" onclick="closeWorkspace()">
            <i class="fas fa-times"></i> Fermer
          </button>
        </div>
      </div>

      <div class="workspace-layout">
        <!-- Code Editor -->
        <div class="code-workspace">
          <div class="code-header">
            <div class="editor-dots">
              <div class="editor-dot red"></div>
              <div class="editor-dot yellow"></div>
              <div class="editor-dot green"></div>
            </div>
            <div class="code-title" id="code-filename">exercice.ino</div>
          </div>
          <div class="code-area" id="code-area">
            <!-- Code will be loaded dynamically -->
          </div>
        </div>

        <!-- Simulation Area -->
        <div class="simulation-area">
          <h3 class="simulation-title"><i class="fas fa-microchip"></i> Simulation ESP32</h3>
          
          <!-- ESP32 Board -->
          <div class="esp32-container">
            <div class="esp32-board">
              <div class="esp32-chip">ESP32</div>
              <div class="esp32-antenna">
                <i class="fas fa-wifi"></i>
              </div>
              
              <!-- Pins Grid -->
              <div class="pins-grid" id="pins-grid">
                <!-- Pins will be generated dynamically -->
              </div>
            </div>
          </div>

          <!-- LEDs -->
          <div class="leds-container" id="leds-container">
            <!-- LEDs will be generated dynamically -->
          </div>

          <!-- Serial Monitor -->
          <div class="serial-monitor" id="serial-monitor">
            <div class="serial-line">Moniteur série initialisé (115200 baud)</div>
            <div class="serial-line">Prêt pour l'exercice...</div>
          </div>
        </div>
      </div>

      <!-- Controls -->
      <div class="workspace-controls">
        <button class="control-btn run" onclick="runCode()">
          <i class="fas fa-play"></i> Exécuter le code
        </button>
        <button class="control-btn reset" onclick="resetSimulation()">
          <i class="fas fa-redo"></i> Réinitialiser
        </button>
        <button class="control-btn check" onclick="checkSolution()">
          <i class="fas fa-check-double"></i> Vérifier la solution
        </button>
        <button class="control-btn" onclick="configureLEDs()">
          <i class="fas fa-cog"></i> Configurer LEDs
        </button>
      </div>

      <!-- Feedback Area -->
      <div class="feedback-area" id="feedback-area">
        <div class="feedback-header">
          <i class="fas fa-comment-dots" id="feedback-icon"></i>
          <h3 class="feedback-title" id="feedback-title">Feedback</h3>
        </div>
        <div class="feedback-content" id="feedback-content">
          <!-- Feedback content will be loaded here -->
        </div>
      </div>
    </div>

    <!-- Achievement Banner -->
    <div id="achievement-banner" style="display: none; position: fixed; top: 100px; right: 20px; 
         background: linear-gradient(135deg, #ff9800, #ff5722); color: white; padding: 1.5rem; 
         border-radius: 10px; box-shadow: 0 5px 20px rgba(0,0,0,0.3); z-index: 1000; max-width: 300px;">
      <div style="display: flex; align-items: center; gap: 15px;">
        <i class="fas fa-trophy" style="font-size: 2rem;"></i>
        <div>
          <h4 style="margin: 0; font-size: 1.2rem;">Exercice réussi!</h4>
          <p style="margin: 5px 0 0 0; font-size: 0.9rem;" id="achievement-message"></p>
        </div>
      </div>
      <button onclick="hideAchievement()" style="position: absolute; top: 5px; right: 10px; 
              background: none; border: none; color: white; cursor: pointer; font-size: 1.2rem;">
        <i class="fas fa-times"></i>
      </button>
    </div>
  </div>
  <script>
    // Global variables
    let currentExercise = 0;
    let pinsConfiguration = {};
    let ledsConfiguration = {};
    let codeLines = [];
    let simulationInterval = null;
    let completedExercises = JSON.parse(localStorage.getItem('completedExercises') || '[]');
    let userCode = {};

    // Exercise data
    const exercises = {
      1: {
        title: "LED Clignotante",
        difficulty: "Débutant",
        description: "Programmez une LED pour qu'elle clignote toutes les secondes (1 seconde allumée, 1 seconde éteinte).",
        objectives: [
          "Utiliser pinMode() pour configurer une broche en sortie",
          "Utiliser digitalWrite() pour contrôler la LED",
          "Utiliser delay() pour les temporisations"
        ],
        template: `void setup() {
  // TODO: Configurer la broche 13 en sortie
  // pinMode(13, OUTPUT);
}

void loop() {
  // TODO: Allumer la LED
  // digitalWrite(13, HIGH);
  
  // TODO: Attendre 1 seconde
  // delay(1000);
  
  // TODO: Éteindre la LED
  
  // TODO: Attendre 1 seconde
  
}`,
        solution: `void setup() {
  pinMode(13, OUTPUT);
}

void loop() {
  digitalWrite(13, HIGH);
  delay(1000);
  digitalWrite(13, LOW);
  delay(1000);
}`,
        pins: [13],
        leds: [{id: 1, color: 'red', pin: 13}],
        hints: [
          "Utilisez pinMode(13, OUTPUT) dans setup()",
          "Utilisez digitalWrite(13, HIGH) pour allumer",
          "Utilisez digitalWrite(13, LOW) pour éteindre",
          "Utilisez delay(1000) pour attendre 1 seconde"
        ],
        test: function(code) {
          // Nettoyer le code des commentaires
          const cleanCode = code.replace(/\/\/.*$/gm, '').replace(/\/\*[\s\S]*?\*\//g, '').trim();
          
          // Vérifier si le code est essentiellement le template (non modifié)
          const cleanTemplate = this.template.replace(/\/\/.*$/gm, '').replace(/\/\*[\s\S]*?\*\//g, '').trim();
          const cleanSolution = this.solution.replace(/\/\/.*$/gm, '').replace(/\/\*[\s\S]*?\*\//g, '').trim();
          
          const isTemplate = cleanCode === cleanTemplate;
          const isSolution = cleanCode === cleanSolution;
          
          if (isTemplate) {
            return {
              isAcceptable: false,
              score: 0,
              feedback: "Code non modifié. Modifiez le template pour résoudre l'exercice."
            };
          }
          
          const tests = {
            // Essentiels
            hasPinMode: /pinMode\s*\(\s*\d+\s*,\s*OUTPUT\s*\)/i.test(cleanCode),
            hasDigitalWriteHigh: /digitalWrite\s*\(\s*\d+\s*,\s*HIGH\s*\)/i.test(cleanCode),
            hasDigitalWriteLow: /digitalWrite\s*\(\s*\d+\s*,\s*LOW\s*\)/i.test(cleanCode),
            hasDelay: /delay\s*\(\s*\d+\s*\)/i.test(cleanCode),
            
            // Bonus
            hasLoopStructure: /void\s+loop\s*\(\s*\)/.test(cleanCode),
            hasSetupStructure: /void\s+setup\s*\(\s*\)/.test(cleanCode)
          };
          
          // Compter les tests essentiels réussis
          const essentialTests = ['hasPinMode', 'hasDigitalWriteHigh', 'hasDigitalWriteLow', 'hasDelay'];
          const essentialPassed = essentialTests.filter(test => tests[test]).length;
          
          // Calcul du score
          const essentialScore = Math.floor((essentialPassed / essentialTests.length) * 70);
          const bonusScore = (tests.hasLoopStructure && tests.hasSetupStructure) ? 20 : 0;
          const totalScore = Math.min(100, essentialScore + bonusScore);
          
          // Déterminer si acceptable
          const isAcceptable = essentialPassed >= 3 && totalScore >= 70;
          
          return {
            ...tests,
            isAcceptable: isAcceptable,
            score: totalScore,
            feedback: isAcceptable ? "Bon travail! Votre code fonctionne." : 
                     `Code incomplet. Score: ${totalScore}%. Il manque: ${essentialTests.filter(t => !tests[t]).map(t => t.replace('has', '')).join(', ')}`
          };
        }
      },
      2: {
        title: "Séquence LED Chassée",
        difficulty: "Intermédiaire",
        description: "Créez un effet de lumière chassée avec 4 LEDs qui s'allument et s'éteignent en séquence.",
        objectives: [
          "Utiliser un tableau pour gérer les broches",
          "Implémenter une boucle for pour contrôler les LEDs",
          "Créer un délai entre chaque étape"
        ],
        template: `int leds[] = {2, 4, 5, 18}; // Broches des LEDs

void setup() {
  // TODO: Configurer toutes les broches en sortie
  for(int i = 0; i < 4; i++) {
    // pinMode(leds[i], OUTPUT);
  }
}

void loop() {
  // TODO: Allumer chaque LED une par une avec délai
  for(int i = 0; i < 4; i++) {
    // Allumer LED i
    
    // Attendre 200ms
    
    // Éteindre LED i
  }
}`,
        solution: `int leds[] = {2, 4, 5, 18};

void setup() {
  for(int i = 0; i < 4; i++) {
    pinMode(leds[i], OUTPUT);
  }
}

void loop() {
  for(int i = 0; i < 4; i++) {
    digitalWrite(leds[i], HIGH);
    delay(200);
    digitalWrite(leds[i], LOW);
  }
}`,
        pins: [2, 4, 5, 18],
        leds: [
          {id: 1, color: 'red', pin: 2},
          {id: 2, color: 'green', pin: 4},
          {id: 3, color: 'blue', pin: 5},
          {id: 4, color: 'yellow', pin: 18}
        ],
        hints: [
          "Utilisez un tableau pour stocker les numéros de broches",
          "Utilisez une boucle for pour configurer toutes les broches",
          "Dans loop(), allumez chaque LED avec digitalWrite(leds[i], HIGH)",
          "Utilisez delay(200) entre chaque changement"
        ],
        test: function(code) {
          const cleanCode = code.replace(/\/\/.*$/gm, '').replace(/\/\*[\s\S]*?\*\//g, '').trim();
          
          const tests = {
            hasArray: /leds\s*\[\s*\]\s*=\s*\{.*\}/.test(cleanCode) || /int\s+leds/.test(cleanCode),
            hasForLoopSetup: /for\s*\(.*i.*<.*4.*\)/.test(cleanCode) && cleanCode.includes('pinMode(leds[i]'),
            hasForLoopLoop: /for\s*\(.*i.*<.*4.*\)/.test(cleanCode) && cleanCode.includes('digitalWrite(leds[i]'),
            hasDelay: /delay\s*\(\s*200\s*\)/.test(cleanCode),
            hasDigitalWrite: /digitalWrite\s*\(/.test(cleanCode)
          };
          
          const essentialTests = ['hasArray', 'hasForLoopLoop', 'hasDigitalWrite'];
          const essentialPassed = essentialTests.filter(test => tests[test]).length;
          const score = Math.floor((essentialPassed / essentialTests.length) * 100);
          
          return {
            ...tests,
            isAcceptable: score >= 70,
            score: score,
            feedback: score >= 70 ? "Code fonctionnel!" : "Améliorez votre solution."
          };
        }
      },
      3: {
        title: "Contrôle PWM (Effet respiration)",
        difficulty: "Intermédiaire",
        description: "Créez un effet de respiration (fade in/fade out) avec une LED en utilisant PWM.",
        objectives: [
          "Utiliser une broche PWM (ex: GPIO 15)",
          "Contrôler la luminosité avec analogWrite()",
          "Implémenter un effet de fondu progressif"
        ],
        template: `int ledPin = 15; // Broche PWM
int brightness = 0;
int fadeAmount = 5;

void setup() {
  // TODO: Pas besoin de pinMode pour PWM
  // Mais vous pouvez initialiser Serial
  // Serial.begin(9600);
}

void loop() {
  // TODO: Appliquer la luminosité actuelle
  // analogWrite(ledPin, brightness);
  
  // TODO: Changer la luminosité
  
  // TODO: Inverser la direction aux limites (0-255)
  
  // TODO: Petit délai pour contrôler la vitesse
  // delay(30);
}`,
        solution: `int ledPin = 15;
int brightness = 0;
int fadeAmount = 5;

void setup() {
  // Pas besoin de pinMode pour PWM sur ESP32
}

void loop() {
  analogWrite(ledPin, brightness);
  
  brightness = brightness + fadeAmount;
  
  if (brightness <= 0 || brightness >= 255) {
    fadeAmount = -fadeAmount;
  }
  
  delay(30);
}`,
        pins: [15],
        leds: [{id: 1, color: 'red', pin: 15, pwm: true}],
        hints: [
          "Utilisez analogWrite(pin, valeur) pour PWM (0-255)",
          "Augmentez brightness à chaque itération",
          "Inversez fadeAmount quand brightness atteint 0 ou 255",
          "Utilisez un petit delay pour contrôler la vitesse"
        ],
        test: function(code) {
          const cleanCode = code.replace(/\/\/.*$/gm, '').replace(/\/\*[\s\S]*?\*\//g, '').trim();
          
          const tests = {
            hasAnalogWrite: /analogWrite\s*\(/.test(cleanCode),
            hasBrightnessChange: /brightness\s*=\s*brightness/.test(cleanCode) || /brightness\s*[+\-]=/.test(cleanCode),
            hasBoundaryCheck: /if\s*\(.*brightness.*<=.*0.*\|.*brightness.*>=.*255/.test(cleanCode),
            hasFadeAmountInversion: /fadeAmount\s*=\s*-\s*fadeAmount/.test(cleanCode),
            hasDelay: /delay\s*\(\s*30\s*\)/.test(cleanCode)
          };
          
          const essentialTests = ['hasAnalogWrite', 'hasBrightnessChange', 'hasBoundaryCheck'];
          const essentialPassed = essentialTests.filter(test => tests[test]).length;
          const score = Math.floor((essentialPassed / essentialTests.length) * 100);
          
          return {
            ...tests,
            isAcceptable: score >= 70,
            score: score,
            feedback: score >= 70 ? "Code PWM fonctionnel!" : "Vérifiez la logique PWM."
          };
        }
      },
      4: {
        title: "LED RGB - Contrôle des couleurs",
        difficulty: "Intermédiaire",
        description: "Contrôlez une LED RGB pour afficher différentes couleurs.",
        objectives: [
          "Contrôler 3 broches PWM simultanément",
          "Créer et utiliser des fonctions",
          "Générer des couleurs RGB"
        ],
        template: `// Broches RGB
int redPin = 12;
int greenPin = 13;
int bluePin = 14;

void setup() {
  // TODO: Configurer les broches en sortie
}

// Fonction pour définir une couleur
void setColor(int red, int green, int blue) {
  // TODO: Écrire les valeurs PWM sur les broches
}

void loop() {
  // TODO: Rouge pur
  
  delay(1000);
  
  // TODO: Vert pur
  
  delay(1000);
  
  // TODO: Bleu pur
  
  delay(1000);
}`,
        solution: `int redPin = 12;
int greenPin = 13;
int bluePin = 14;

void setup() {
  // Broches PWM - pas besoin de pinMode sur ESP32
}

void setColor(int red, int green, int blue) {
  analogWrite(redPin, red);
  analogWrite(greenPin, green);
  analogWrite(bluePin, blue);
}

void loop() {
  setColor(255, 0, 0);   // Rouge
  delay(1000);
  
  setColor(0, 255, 0);   // Vert
  delay(1000);
  
  setColor(0, 0, 255);   // Bleu
  delay(1000);
}`,
        pins: [12, 13, 14],
        leds: [{id: 1, color: 'red', pin: 12, rgb: true}],
        hints: [
          "Utilisez analogWrite() pour chaque broche PWM",
          "Créez une fonction setColor() pour simplifier le code",
          "Les valeurs RGB vont de 0 à 255",
          "Rouge = (255, 0, 0), Vert = (0, 255, 0), Bleu = (0, 0, 255)"
        ],
        test: function(code) {
          const cleanCode = code.replace(/\/\/.*$/gm, '').replace(/\/\*[\s\S]*?\*\//g, '').trim();
          
          const tests = {
            hasSetColorFunction: /void\s+setColor\s*\(/.test(cleanCode),
            hasAnalogWriteCalls: (cleanCode.match(/analogWrite\(/g) || []).length >= 3,
            hasColorCalls: /setColor\s*\(\s*255\s*,\s*0\s*,\s*0\s*\)/.test(cleanCode) &&
                         /setColor\s*\(\s*0\s*,\s*255\s*,\s*0\s*\)/.test(cleanCode) &&
                         /setColor\s*\(\s*0\s*,\s*0\s*,\s*255\s*\)/.test(cleanCode),
            hasDelays: (cleanCode.match(/delay\s*\(/g) || []).length >= 3
          };
          
          const essentialTests = ['hasSetColorFunction', 'hasAnalogWriteCalls', 'hasColorCalls'];
          const essentialPassed = essentialTests.filter(test => tests[test]).length;
          const score = Math.floor((essentialPassed / essentialTests.length) * 100);
          
          return {
            ...tests,
            isAcceptable: score >= 70,
            score: score,
            feedback: score >= 70 ? "RGB fonctionnel!" : "Vérifiez la fonction setColor()."
          };
        }
      },
      5: {
        title: "Feu tricolore",
        difficulty: "Intermédiaire",
        description: "Simulez un feu de circulation avec séquence précise.",
        objectives: [
          "Coordonner plusieurs LEDs",
          "Implémenter des temporisations complexes",
          "Utiliser millis() pour un timing précis"
        ],
        template: `// Broches des LEDs
int redPin = 25;
int yellowPin = 26;
int greenPin = 27;

unsigned long previousMillis = 0;
int currentState = 0; // 0: rouge, 1: rouge+jaune, 2: vert, 3: jaune

void setup() {
  // TODO: Configurer les broches en sortie
}

void loop() {
  unsigned long currentMillis = millis();
  
  switch(currentState) {
    case 0: // Rouge
      // TODO: Allumer rouge, éteindre autres
      if (currentMillis - previousMillis >= 3000) {
        previousMillis = currentMillis;
        currentState = 1;
      }
      break;
      
    case 1: // Rouge + Jaune
      // TODO: Allumer rouge et jaune
      if (currentMillis - previousMillis >= 1000) {
        previousMillis = currentMillis;
        currentState = 2;
      }
      break;
      
    case 2: // Vert
      // TODO: Allumer vert, éteindre autres
      if (currentMillis - previousMillis >= 3000) {
        previousMillis = currentMillis;
        currentState = 3;
      }
      break;
      
    case 3: // Jaune
      // TODO: Allumer jaune
      if (currentMillis - previousMillis >= 1000) {
        previousMillis = currentMillis;
        currentState = 0;
      }
      break;
  }
}`,
        solution: `int redPin = 25;
int yellowPin = 26;
int greenPin = 27;

unsigned long previousMillis = 0;
int currentState = 0;

void setup() {
  pinMode(redPin, OUTPUT);
  pinMode(yellowPin, OUTPUT);
  pinMode(greenPin, OUTPUT);
}

void loop() {
  unsigned long currentMillis = millis();
  
  switch(currentState) {
    case 0:
      digitalWrite(redPin, HIGH);
      digitalWrite(yellowPin, LOW);
      digitalWrite(greenPin, LOW);
      if (currentMillis - previousMillis >= 3000) {
        previousMillis = currentMillis;
        currentState = 1;
      }
      break;
      
    case 1:
      digitalWrite(redPin, HIGH);
      digitalWrite(yellowPin, HIGH);
      digitalWrite(greenPin, LOW);
      if (currentMillis - previousMillis >= 1000) {
        previousMillis = currentMillis;
        currentState = 2;
      }
      break;
      
    case 2:
      digitalWrite(redPin, LOW);
      digitalWrite(yellowPin, LOW);
      digitalWrite(greenPin, HIGH);
      if (currentMillis - previousMillis >= 3000) {
        previousMillis = currentMillis;
        currentState = 3;
      }
      break;
      
    case 3:
      digitalWrite(redPin, LOW);
      digitalWrite(yellowPin, HIGH);
      digitalWrite(greenPin, LOW);
      if (currentMillis - previousMillis >= 1000) {
        previousMillis = currentMillis;
        currentState = 0;
      }
      break;
  }
}`,
        pins: [25, 26, 27],
        leds: [
          {id: 1, color: 'red', pin: 25},
          {id: 2, color: 'yellow', pin: 26},
          {id: 3, color: 'green', pin: 27}
        ],
        hints: [
          "Utilisez millis() pour un timing précis sans bloquer",
          "Maintenez un état (state) pour savoir quelle couleur afficher",
          "Rouge: 3s → Rouge+Jaune: 1s → Vert: 3s → Jaune: 1s",
          "Utilisez switch/case pour gérer les différents états"
        ],
        test: function(code) {
          const cleanCode = code.replace(/\/\/.*$/gm, '').replace(/\/\*[\s\S]*?\*\//g, '').trim();
          
          const tests = {
            hasThreePins: /25.*26.*27/.test(cleanCode),
            hasPinModeAll: (cleanCode.match(/pinMode\(/g) || []).length >= 2,
            hasMillis: /millis\s*\(/.test(cleanCode),
            hasSwitchCase: /switch\s*\(/.test(cleanCode) && /case\s+0:/.test(cleanCode),
            hasStateManagement: /currentState/.test(cleanCode),
            hasDigitalWrites: (cleanCode.match(/digitalWrite\(/g) || []).length >= 6
          };
          
          const essentialTests = ['hasThreePins', 'hasPinModeAll', 'hasSwitchCase', 'hasDigitalWrites'];
          const essentialPassed = essentialTests.filter(test => tests[test]).length;
          const score = Math.floor((essentialPassed / essentialTests.length) * 100);
          
          return {
            ...tests,
            isAcceptable: score >= 70,
            score: score,
            feedback: score >= 70 ? "Feu tricolore fonctionnel!" : "Vérifiez la logique des états."
          };
        }
      },
      6: {
        title: "Animation Lumineuse Complexe",
        difficulty: "Avancé",
        description: "Créez une animation complexe avec 6 LEDs et effets variés.",
        objectives: [
          "Gérer plusieurs patterns d'animation",
          "Utiliser des structures de contrôle avancées",
          "Optimiser le code pour fluidité"
        ],
        template: `int leds[] = {2, 4, 5, 18, 19, 21};
int numLeds = 6;
int pattern = 0;
unsigned long lastChange = 0;

void setup() {
  // TODO: Configurer toutes les broches
}

void loop() {
  unsigned long currentTime = millis();
  
  // Changer de pattern toutes les 5 secondes
  if (currentTime - lastChange >= 5000) {
    lastChange = currentTime;
    pattern = (pattern + 1) % 4;
  }
  
  switch(pattern) {
    case 0:
      patternCascade();
      break;
    case 1:
      patternBounce();
      break;
    case 2:
      patternRandom();
      break;
    case 3:
      patternAllBlink();
      break;
  }
}

void patternCascade() {
  // TODO: Effet cascade (une LED après l'autre)
}

void patternBounce() {
  // TODO: Effet rebond (aller-retour)
}

void patternRandom() {
  // TODO: LEDs aléatoires
}

void patternAllBlink() {
  // TODO: Toutes les LEDs clignotent ensemble
}`,
        solution: `int leds[] = {2, 4, 5, 18, 19, 21};
int numLeds = 6;
int pattern = 0;
unsigned long lastChange = 0;
unsigned long lastAnimation = 0;
int animationState = 0;

void setup() {
  for(int i = 0; i < numLeds; i++) {
    pinMode(leds[i], OUTPUT);
  }
}

void loop() {
  unsigned long currentTime = millis();
  
  if (currentTime - lastChange >= 5000) {
    lastChange = currentTime;
    pattern = (pattern + 1) % 4;
    animationState = 0;
  }
  
  if (currentTime - lastAnimation >= 200) {
    lastAnimation = currentTime;
    
    switch(pattern) {
      case 0:
        patternCascade();
        break;
      case 1:
        patternBounce();
        break;
      case 2:
        patternRandom();
        break;
      case 3:
        patternAllBlink();
        break;
    }
  }
}

void patternCascade() {
  for(int i = 0; i < numLeds; i++) {
    digitalWrite(leds[i], i == animationState ? HIGH : LOW);
  }
  animationState = (animationState + 1) % numLeds;
}

void patternBounce() {
  static int direction = 1;
  
  for(int i = 0; i < numLeds; i++) {
    digitalWrite(leds[i], i == animationState ? HIGH : LOW);
  }
  
  animationState += direction;
  if (animationState == 0 || animationState == numLeds - 1) {
    direction = -direction;
  }
}

void patternRandom() {
  for(int i = 0; i < numLeds; i++) {
    digitalWrite(leds[i], random(2) == 1 ? HIGH : LOW);
  }
}

void patternAllBlink() {
  for(int i = 0; i < numLeds; i++) {
    digitalWrite(leds[i], animationState % 2 == 0 ? HIGH : LOW);
  }
  animationState++;
}`,
        pins: [2, 4, 5, 18, 19, 21],
        leds: [
          {id: 1, color: 'red', pin: 2},
          {id: 2, color: 'green', pin: 4},
          {id: 3, color: 'blue', pin: 5},
          {id: 4, color: 'yellow', pin: 18},
          {id: 5, color: 'red', pin: 19},
          {id: 6, color: 'green', pin: 21}
        ],
        hints: [
          "Utilisez millis() pour les animations non-bloquantes",
          "Créez plusieurs fonctions pour différents patterns",
          "Gérez un état d'animation pour savoir où vous en êtes",
          "Utilisez random() pour l'effet aléatoire"
        ],
        test: function(code) {
          const cleanCode = code.replace(/\/\/.*$/gm, '').replace(/\/\*[\s\S]*?\*\//g, '').trim();
          
          const tests = {
            hasMultiplePatterns: /patternCascade|patternBounce|patternRandom|patternAllBlink/.test(cleanCode),
            hasMillis: /millis\s*\(/.test(cleanCode),
            hasForLoop: /for\s*\(/.test(cleanCode),
            hasRandom: /random\s*\(/.test(cleanCode),
            hasMultipleFunctions: (cleanCode.match(/void\s+\w+\s*\(/g) || []).length >= 3,
            hasPinModeLoop: /for.*pinMode.*leds\[i\]/.test(cleanCode)
          };
          
          const essentialTests = ['hasMultiplePatterns', 'hasMillis', 'hasPinModeLoop'];
          const essentialPassed = essentialTests.filter(test => tests[test]).length;
          const score = Math.floor((essentialPassed / essentialTests.length) * 100);
          
          return {
            ...tests,
            isAcceptable: score >= 70,
            score: score,
            feedback: score >= 70 ? "Animation complexe réussie!" : "Implémentez plusieurs patterns."
          };
        }
      },
      7: {
        title: "LED avec bouton",
        difficulty: "Normal",
        description: "Allumez une LED lorsque vous appuyez sur un bouton.",
        objectives: [
          "Lire l'état d'une entrée numérique",
          "Utiliser digitalRead()",
          "Récupérer l'état d'un bouton"
        ],
        template: `int ledPin = 13;
int buttonPin = 12;

void setup() {
  // TODO: Configurer les broches
}

void loop() {
  // TODO: Lire l'état du bouton
  // int buttonState = digitalRead(buttonPin);
  
  // TODO: Allumer la LED si bouton pressé
}`,
        solution: `int ledPin = 13;
int buttonPin = 12;

void setup() {
  pinMode(ledPin, OUTPUT);
  pinMode(buttonPin, INPUT_PULLUP);
}

void loop() {
  int buttonState = digitalRead(buttonPin);
  
  if (buttonState == LOW) {
    digitalWrite(ledPin, HIGH);
  } else {
    digitalWrite(ledPin, LOW);
  }
}`,
        pins: [12, 13],
        leds: [{id: 1, color: 'red', pin: 13}],
        hints: [
          "Utilisez INPUT_PULLUP pour le bouton",
          "digitalRead() retourne HIGH ou LOW",
          "Un bouton avec PULLUP est LOW quand pressé",
          "Utilisez if/else pour contrôler la LED"
        ],
        test: function(code) {
          const cleanCode = code.replace(/\/\/.*$/gm, '').replace(/\/\*[\s\S]*?\*\//g, '').trim();
          
          const tests = {
            hasDigitalRead: /digitalRead\s*\(/.test(cleanCode),
            hasInputPullup: /INPUT_PULLUP/.test(cleanCode),
            hasConditional: /if\s*\(/.test(cleanCode) && /==/.test(cleanCode),
            hasBothPins: /12.*13/.test(cleanCode),
            hasPinModeBoth: (cleanCode.match(/pinMode\(/g) || []).length >= 2
          };
          
          const essentialTests = ['hasDigitalRead', 'hasInputPullup', 'hasConditional'];
          const essentialPassed = essentialTests.filter(test => tests[test]).length;
          const score = Math.floor((essentialPassed / essentialTests.length) * 100);
          
          return {
            ...tests,
            isAcceptable: score >= 70,
            score: score,
            feedback: score >= 70 ? "Bouton fonctionnel!" : "Vérifiez la lecture du bouton."
          };
        }
      },
      8: {
        title: "Clignotement avec potentiomètre",
        difficulty: "Normal",
        description: "Contrôlez la vitesse de clignotement avec un potentiomètre.",
        objectives: [
          "Lire une entrée analogique",
          "Utiliser analogRead()",
          "Mapper des valeurs"
        ],
        template: `int ledPin = 13;
int potPin = 34;
int delayTime;

void setup() {
  // TODO: Configurer la broche LED
}

void loop() {
  // TODO: Lire la valeur du potentiomètre (0-4095)
  // int potValue = analogRead(potPin);
  
  // TODO: Convertir en temps de délai (ex: 50-1000ms)
  // delayTime = map(potValue, 0, 4095, 50, 1000);
  
  // TODO: Faire clignoter avec cette vitesse
}`,
        solution: `int ledPin = 13;
int potPin = 34;
int delayTime;

void setup() {
  pinMode(ledPin, OUTPUT);
}

void loop() {
  int potValue = analogRead(potPin);
  
  delayTime = map(potValue, 0, 4095, 50, 1000);
  
  digitalWrite(ledPin, HIGH);
  delay(delayTime);
  digitalWrite(ledPin, LOW);
  delay(delayTime);
}`,
        pins: [13, 34],
        leds: [{id: 1, color: 'red', pin: 13}],
        hints: [
          "analogRead() retourne 0-4095 sur ESP32",
          "map() convertit une plage de valeurs",
          "Plus le potentiomètre est haut, plus le délai est long",
          "Utilisez la valeur mapée dans delay()"
        ],
        test: function(code) {
          const cleanCode = code.replace(/\/\/.*$/gm, '').replace(/\/\*[\s\S]*?\*\//g, '').trim();
          
          const tests = {
            hasAnalogRead: /analogRead\s*\(/.test(cleanCode),
            hasMap: /map\s*\(/.test(cleanCode),
            hasDigitalWrite: /digitalWrite\s*\(/.test(cleanCode),
            hasDelayVariable: /delayTime/.test(cleanCode),
            hasBlinkPattern: /digitalWrite.*HIGH.*delay.*digitalWrite.*LOW.*delay/.test(cleanCode.replace(/\s/g, ''))
          };
          
          const essentialTests = ['hasAnalogRead', 'hasMap', 'hasBlinkPattern'];
          const essentialPassed = essentialTests.filter(test => tests[test]).length;
          const score = Math.floor((essentialPassed / essentialTests.length) * 100);
          
          return {
            ...tests,
            isAcceptable: score >= 70,
            score: score,
            feedback: score >= 70 ? "Potentiomètre fonctionnel!" : "Vérifiez la lecture analogique."
          };
        }
      },
      9: {
        title: "Contrôle LED avec 2 boutons",
        difficulty: "Normal",
        description: "Augmentez et diminuez la luminosité avec deux boutons.",
        objectives: [
          "Gérer plusieurs entrées",
          "Implémenter un compteur",
          "Limiter les valeurs"
        ],
        template: `int ledPin = 13;
int buttonUpPin = 12;
int buttonDownPin = 14;
int brightness = 128;

void setup() {
  // TODO: Configurer broches
}

void loop() {
  // TODO: Lire bouton augmentation
  // if (digitalRead(buttonUpPin) == LOW) {
  //   brightness += 10;
  // }
  
  // TODO: Lire bouton diminution
  
  // TODO: Limiter brightness entre 0 et 255
  
  // TODO: Appliquer la luminosité
  // analogWrite(ledPin, brightness);
  
  delay(100);
}`,
        solution: `int ledPin = 13;
int buttonUpPin = 12;
int buttonDownPin = 14;
int brightness = 128;

void setup() {
  pinMode(ledPin, OUTPUT);
  pinMode(buttonUpPin, INPUT_PULLUP);
  pinMode(buttonDownPin, INPUT_PULLUP);
}

void loop() {
  if (digitalRead(buttonUpPin) == LOW) {
    brightness += 10;
  }
  
  if (digitalRead(buttonDownPin) == LOW) {
    brightness -= 10;
  }
  
  brightness = constrain(brightness, 0, 255);
  
  analogWrite(ledPin, brightness);
  
  delay(100);
}`,
        pins: [12, 13, 14],
        leds: [{id: 1, color: 'red', pin: 13, pwm: true}],
        hints: [
          "Utilisez INPUT_PULLUP pour les boutons",
          "constrain() limite les valeurs entre min et max",
          "Augmentez/diminuez la valeur par pas de 10",
          "Les boutons sont LOW quand pressés"
        ],
        test: function(code) {
          const cleanCode = code.replace(/\/\/.*$/gm, '').replace(/\/\*[\s\S]*?\*\//g, '').trim();
          
          const tests = {
            hasTwoButtons: /12.*14/.test(cleanCode),
            hasConstrains: /constrain\s*\(/.test(cleanCode),
            hasBrightnessControl: /brightness\s*[+\-]=\s*10/.test(cleanCode),
            hasAnalogWrite: /analogWrite\s*\(/.test(cleanCode),
            hasDigitalReadBoth: (cleanCode.match(/digitalRead\(/g) || []).length >= 2
          };
          
          const essentialTests = ['hasTwoButtons', 'hasBrightnessControl', 'hasAnalogWrite'];
          const essentialPassed = essentialTests.filter(test => tests[test]).length;
          const score = Math.floor((essentialPassed / essentialTests.length) * 100);
          
          return {
            ...tests,
            isAcceptable: score >= 70,
            score: score,
            feedback: score >= 70 ? "Contrôle PWM avec boutons réussi!" : "Vérifiez la gestion des boutons."
          };
        }
      },
      10: {
        title: "Séquence avec interruption",
        difficulty: "Normal",
        description: "Changez la séquence LED avec un bouton par interruption.",
        objectives: [
          "Utiliser les interruptions",
          "Changer de mode dynamiquement",
          "Gérer les variables volatiles"
        ],
        template: `int leds[] = {2, 4, 5, 18};
int buttonPin = 12;
volatile bool changePattern = false;
int pattern = 0;

void setup() {
  // TODO: Configurer LEDs
  
  // TODO: Configurer bouton avec interruption
  // attachInterrupt(digitalPinToInterrupt(buttonPin), changePatternISR, FALLING);
}

void loop() {
  if (changePattern) {
    pattern = (pattern + 1) % 3;
    changePattern = false;
  }
  
  switch(pattern) {
    case 0:
      pattern1();
      break;
    case 1:
      pattern2();
      break;
    case 2:
      pattern3();
      break;
  }
}

void pattern1() {
  // TODO: Séquence simple
}

void pattern2() {
  // TODO: Séquence inversée
}

void pattern3() {
  // TODO: Clignotement groupé
}

void changePatternISR() {
  changePattern = true;
}`,
        solution: `int leds[] = {2, 4, 5, 18};
int buttonPin = 12;
volatile bool changePattern = false;
int pattern = 0;
int currentLed = 0;

void setup() {
  for(int i = 0; i < 4; i++) {
    pinMode(leds[i], OUTPUT);
  }
  pinMode(buttonPin, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(buttonPin), changePatternISR, FALLING);
}

void loop() {
  if (changePattern) {
    pattern = (pattern + 1) % 3;
    changePattern = false;
    currentLed = 0;
    
    for(int i = 0; i < 4; i++) {
      digitalWrite(leds[i], LOW);
    }
  }
  
  switch(pattern) {
    case 0:
      pattern1();
      break;
    case 1:
      pattern2();
      break;
    case 2:
      pattern3();
      break;
  }
  delay(200);
}

void pattern1() {
  digitalWrite(leds[currentLed], HIGH);
  delay(100);
  digitalWrite(leds[currentLed], LOW);
  currentLed = (currentLed + 1) % 4;
}

void pattern2() {
  digitalWrite(leds[3 - currentLed], HIGH);
  delay(100);
  digitalWrite(leds[3 - currentLed], LOW);
  currentLed = (currentLed + 1) % 4;
}

void pattern3() {
  for(int i = 0; i < 4; i++) {
    digitalWrite(leds[i], i % 2 == currentLed % 2 ? HIGH : LOW);
  }
  currentLed++;
}

void changePatternISR() {
  changePattern = true;
}`,
        pins: [2, 4, 5, 12, 18],
        leds: [
          {id: 1, color: 'red', pin: 2},
          {id: 2, color: 'green', pin: 4},
          {id: 3, color: 'blue', pin: 5},
          {id: 4, color: 'yellow', pin: 18}
        ],
        hints: [
          "attachInterrupt() permet de réagir immédiatement",
          "Les variables partagées avec l'ISR doivent être 'volatile'",
          "FALLING déclenche quand le signal passe de HIGH à LOW",
          "Réinitialisez les LEDs quand vous changez de pattern"
        ],
        test: function(code) {
          const cleanCode = code.replace(/\/\/.*$/gm, '').replace(/\/\*[\s\S]*?\*\//g, '').trim();
          
          const tests = {
            hasInterrupt: /attachInterrupt\s*\(/.test(cleanCode),
            hasVolatile: /volatile/.test(cleanCode),
            hasISR: /ISR/.test(cleanCode) || /changePatternISR/.test(cleanCode),
            hasMultiplePatterns: /pattern1|pattern2|pattern3/.test(cleanCode),
            hasSwitchPattern: /switch\s*\(.*pattern/.test(cleanCode)
          };
          
          const essentialTests = ['hasInterrupt', 'hasVolatile', 'hasMultiplePatterns'];
          const essentialPassed = essentialTests.filter(test => tests[test]).length;
          const score = Math.floor((essentialPassed / essentialTests.length) * 100);
          
          return {
            ...tests,
            isAcceptable: score >= 70,
            score: score,
            feedback: score >= 70 ? "Interruptions fonctionnelles!" : "Vérifiez la configuration des interruptions."
          };
        }
      }
    };

    // Arduino Code Interpreter - Version simplifiée et robuste
    class ArduinoInterpreter {
      constructor() {
        this.variables = {};
        this.pinModes = {};
        this.pinStates = {};
        this.serialOutput = [];
        this.delayQueue = 0;
        this.loopCounter = 0;
        this.maxLoops = 10;
        this.hasErrors = false;
        this.errorMessages = [];
      }
      
      // Parse and execute Arduino code
      execute(code) {
        this.reset();
        
        try {
          // Validation syntaxique d'abord
          const syntaxErrors = this.validateSyntax(code);
          if (syntaxErrors.length > 0) {
            this.errorMessages.push(...syntaxErrors);
            this.hasErrors = true;
            this.serialOutput.push('❌ Erreurs de syntaxe détectées:');
            syntaxErrors.forEach(error => {
              this.serialOutput.push(`   • ${error}`);
            });
            return this.createResult();
          }
          
          // Recherche simple des fonctions Arduino
          this.findAndExecuteArduinoFunctions(code);
          
          // Si aucune fonction Arduino trouvée
          if (this.serialOutput.filter(line => line.startsWith('✓')).length === 0) {
            this.serialOutput.push("⚠️  Aucune fonction Arduino valide trouvée");
          }
          
          return this.createResult();
        } catch (error) {
          this.serialOutput.push(`❌ Erreur: ${error.message}`);
          this.hasErrors = true;
          return this.createResult();
        }
      }
      reset() {
        this.variables = {};
        this.pinModes = {};
        this.pinStates = {};
        this.serialOutput = [];
        this.delayQueue = 0;
        this.loopCounter = 0;
        this.hasErrors = false;
        this.errorMessages = [];
      }
   // AJOUTER cette méthode à la classe ArduinoInterpreter :
validateSyntax(code) {
    const errors = [];
    const lines = code.split('\n');
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      const lineNum = i + 1;
      
      if (!line || line.startsWith('//')) continue;
      
      // Vérifier digitalWrite incomplet
      if (line.includes('digitalWrite(')) {
        const match = line.match(/digitalWrite\s*\(\s*([^,)]+)\s*,?\s*([^)]*)?/);
        if (!match || !match[2] || match[2].trim() === '') {
          errors.push(`Ligne ${lineNum}: digitalWrite() incomplet. Exemple: digitalWrite(13, HIGH)`);
        } else if (match[2] && !['HIGH', 'LOW'].includes(match[2].trim())) {
          errors.push(`Ligne ${lineNum}: digitalWrite() doit utiliser HIGH ou LOW, pas "${match[2].trim()}"`);
        }
      }
      
      // Vérifier analogWrite incomplet
      if (line.includes('analogWrite(')) {
        const match = line.match(/analogWrite\s*\(\s*([^,)]+)\s*,?\s*([^)]*)?/);
        if (!match || !match[2] || match[2].trim() === '') {
          errors.push(`Ligne ${lineNum}: analogWrite() incomplet. Exemple: analogWrite(13, 128)`);
        }
      }
      
      // Vérifier delay incomplet
      if (line.includes('delay(') && !line.includes('delay(')) {
        const match = line.match(/delay\s*\(\s*([^)]*)\s*\)/);
        if (!match || !match[1] || match[1].trim() === '') {
          errors.push(`Ligne ${lineNum}: delay() incomplet. Exemple: delay(1000)`);
        }
      }
    }
    
    return errors;
  }
    
    
      findAndExecuteArduinoFunctions(code) {
        const lines = code.split('\n');
        
        for (let line of lines) {
          const trimmed = line.trim();
          if (!trimmed || trimmed.startsWith('//')) continue;
          
          // pinMode
          const pinModeMatch = trimmed.match(/pinMode\s*\(\s*(\d+)\s*,\s*(OUTPUT|INPUT|INPUT_PULLUP)\s*\)/i);
          if (pinModeMatch) {
            const pin = parseInt(pinModeMatch[1]);
            const mode = pinModeMatch[2];
            this.pinModes[pin] = mode;
            this.serialOutput.push(`✓ pinMode(${pin}, ${mode})`);
          }
          
          // digitalWrite
          const digitalWriteMatch = trimmed.match(/digitalWrite\s*\(\s*(\d+)\s*,\s*(HIGH|LOW)\s*\)/i);
          if (digitalWriteMatch) {
            const pin = parseInt(digitalWriteMatch[1]);
            const value = digitalWriteMatch[2];
            this.pinStates[pin] = value === 'HIGH' ? 1 : 0;
            this.serialOutput.push(`✓ digitalWrite(${pin}, ${value})`);
          }
          
          // analogWrite
          const analogWriteMatch = trimmed.match(/analogWrite\s*\(\s*(\d+)\s*,\s*(\d+)\s*\)/i);
          if (analogWriteMatch) {
            const pin = parseInt(analogWriteMatch[1]);
            let value = parseInt(analogWriteMatch[2]);
            value = Math.min(255, Math.max(0, value));
            this.pinStates[pin] = value / 255;
            this.serialOutput.push(`✓ analogWrite(${pin}, ${value})`);
          }
          
          // delay
          const delayMatch = trimmed.match(/delay\s*\(\s*(\d+)\s*\)/i);
          if (delayMatch) {
            this.delayQueue += parseInt(delayMatch[1]);
            this.serialOutput.push(`✓ delay(${delayMatch[1]})`);
          }
          
          // digitalRead
          const digitalReadMatch = trimmed.match(/digitalRead\s*\(\s*(\d+)\s*\)/i);
          if (digitalReadMatch) {
            const pin = parseInt(digitalReadMatch[1]);
            this.serialOutput.push(`✓ digitalRead(${pin})`);
          }
          
          // analogRead
          const analogReadMatch = trimmed.match(/analogRead\s*\(\s*(\d+)\s*\)/i);
          if (analogReadMatch) {
            const pin = parseInt(analogReadMatch[1]);
            this.serialOutput.push(`✓ analogRead(${pin})`);
          }
          
          // map
          const mapMatch = trimmed.match(/map\s*\(/i);
          if (mapMatch) {
            this.serialOutput.push(`✓ map()`);
          }
          
          // millis
          const millisMatch = trimmed.match(/millis\s*\(/i);
          if (millisMatch) {
            this.serialOutput.push(`✓ millis()`);
          }
          
          // Serial.begin
          const serialBeginMatch = trimmed.match(/Serial\.begin\s*\(\s*(\d+)\s*\)/i);
          if (serialBeginMatch) {
            this.serialOutput.push(`✓ Serial.begin(${serialBeginMatch[1]})`);
          }
        }
      }
      
      createResult() {
        return { 
          success: !this.hasErrors, 
          output: this.serialOutput, 
          pinStates: this.pinStates,
          errors: this.errorMessages
        };
      }
      
      getPinState(pin) {
        return this.pinStates[pin] || 0;
      }
    }

    // Initialize page
    document.addEventListener('DOMContentLoaded', function() {
      updateProgress();
      loadExerciseStatus();
      initPinsConfiguration();
    });
// REMPLACER la fonction isCodeModified() par :
// Vérifier si le code est vraiment modifié (pas juste décommenté)
function isCodeTrulyModified(code, template) {
    // Enlever les commentaires et espaces
    const cleanCode = removeCommentsAndWhitespace(code);
    const cleanTemplate = removeCommentsAndWhitespace(template);
    
    // Si identique au template, pas modifié
    if (cleanCode === cleanTemplate) {
      return false;
    }
    
    // Séparer en lignes significatives
    const codeLines = code.split('\n').filter(line => {
      const trimmed = line.trim();
      return trimmed && 
             !trimmed.startsWith('//') && 
             !trimmed.startsWith('/*') &&
             !trimmed.startsWith('* ') &&
             trimmed !== '{' && 
             trimmed !== '}';
    });
    
    const templateLines = template.split('\n').filter(line => {
      const trimmed = line.trim();
      return trimmed && 
             !trimmed.startsWith('//') && 
             !trimmed.startsWith('/*') &&
             !trimmed.startsWith('* ') &&
             trimmed !== '{' && 
             trimmed !== '}';
    });
    
    // Si peu de lignes ajoutées, probablement incomplet
    if (codeLines.length <= templateLines.length + 1) {
      return false;
    }
    
    // Compter les nouvelles instructions Arduino
    const arduinoFunctions = ['pinMode', 'digitalWrite', 'analogWrite', 'delay', 
                            'digitalRead', 'analogRead', 'millis', 'map', 'constrain'];
    
    let newFunctionCount = 0;
    codeLines.forEach(line => {
      arduinoFunctions.forEach(func => {
        if (line.includes(func + '(')) {
          newFunctionCount++;
        }
      });
    });
    
    // Pour l'exercice 1, besoin d'au moins 4-5 fonctions Arduino
    if (newFunctionCount < 4) {
      return false;
    }
    
    return true;
  }
   
 
  // Load an exercise
    function loadExercise(num) {
      currentExercise = num;
      const exercise = exercises[num];
      
      if (!exercise) {
        console.error(`Exercise ${num} not found`);
        alert(`Exercice ${num} non disponible`);
        return;
      }
      
      // Show workspace
      const workspace = document.getElementById('exercise-workspace');
      workspace.style.display = 'block';
      
      // Update workspace
      document.getElementById('workspace-title').textContent = `Exercice #${num}: ${exercise.title}`;
      document.getElementById('code-filename').textContent = `ex${num}.ino`;
      
      // Load code template
      loadCodeTemplate(exercise.template);
      
      // Configure pins and LEDs
      configurePins(exercise.pins);
      configureExerciseLEDs(exercise.leds);
      
      // Hide feedback
      const feedbackArea = document.getElementById('feedback-area');
      feedbackArea.classList.remove('show');
      
      // Scroll to workspace
      workspace.scrollIntoView({ behavior: 'smooth' });
      
      // Clear serial monitor
      clearSerialMonitor();
      addSerialLine(`=== Exercice #${num}: ${exercise.title} ===`);
      addSerialLine('Prêt à coder! Tapez "Exécuter" pour tester.');
    }

    // Load code template
    function loadCodeTemplate(template) {
      const codeArea = document.getElementById('code-area');
      if (!codeArea) {
        console.error('code-area element not found');
        return;
      }
      
      codeLines = template.split('\n');
      userCode[currentExercise] = template;
      
      codeArea.innerHTML = '';
      codeLines.forEach((line, index) => {
        const lineDiv = document.createElement('div');
        lineDiv.className = 'code-line';
        
        // Line number
        const lineNumber = document.createElement('span');
        lineNumber.className = 'line-number';
        lineNumber.textContent = index + 1;
        
        // Code display
        const codeSpan = document.createElement('span');
        codeSpan.className = 'code-display';
        codeSpan.innerHTML = highlightSyntax(line);
        
        // Hidden input for editing
        const codeInput = document.createElement('input');
        codeInput.type = 'text';
        codeInput.className = 'code-input';
        codeInput.value = line;
        codeInput.dataset.line = index;
        codeInput.style.display = 'none';
        
        lineDiv.appendChild(lineNumber);
        lineDiv.appendChild(codeSpan);
        lineDiv.appendChild(codeInput);
        codeArea.appendChild(lineDiv);
        
        // Edit on click
        codeSpan.addEventListener('click', function() {
          this.style.display = 'none';
          codeInput.style.display = 'inline';
          codeInput.focus();
          codeInput.setSelectionRange(codeInput.value.length, codeInput.value.length);
        });
        
        // Save on blur
        codeInput.addEventListener('blur', function() {
          updateCodeLine(parseInt(this.dataset.line), this.value);
          codeSpan.innerHTML = highlightSyntax(this.value);
          codeSpan.style.display = 'inline';
          this.style.display = 'none';
        });
        
        // Enter key support
        codeInput.addEventListener('keydown', function(e) {
          if (e.key === 'Enter') {
            this.blur();
          }
        });
      });
    }
    
    // Highlight syntax
    function highlightSyntax(line) {
      let html = '';
      let inComment = false;
      let inString = false;
      let current = '';
      
      for (let i = 0; i < line.length; i++) {
        const char = line[i];
        const nextChar = i + 1 < line.length ? line[i + 1] : '';
        
        // Comment start
        if (!inString && char === '/' && nextChar === '/') {
          html += wrapCurrent(current);
          current = '//';
          inComment = true;
          i++;
          continue;
        }
        
        // String start/end
        if (!inComment && char === '"') {
          html += wrapCurrent(current);
          current = '"';
          inString = !inString;
          continue;
        }
        
        current += char;
        
        // End of line
        if (i === line.length - 1) {
          html += wrapCurrent(current, inComment, inString);
        }
      }
      
      return html;
    }
    
    function wrapCurrent(text, isComment = false, isString = false) {
      if (!text) return '';
      
      const escaped = text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
      
      if (isComment) {
        return '<span class="code-comment">' + escaped + '</span>';
      }
      
      if (isString) {
        return '<span class="code-string">' + escaped + '</span>';
      }
      
      let result = escaped;
      
      // Keywords
      const keywords = ['void', 'setup', 'loop', 'int', 'float', 'if', 'else', 
                        'for', 'while', 'return', 'const', 'bool', 'true', 'false',
                        'switch', 'case', 'break', 'default', 'static', 'volatile',
                        'unsigned', 'long', 'short', 'byte', 'char'];
      keywords.forEach(keyword => {
        const regex = new RegExp('\\b' + keyword + '\\b', 'g');
        result = result.replace(regex, '<span class="code-keyword">$&</span>');
      });
      
      // Functions
      const functions = ['pinMode', 'digitalWrite', 'digitalRead', 'analogWrite', 
                         'analogRead', 'delay', 'millis', 'micros', 'Serial.begin',
                         'Serial.print', 'Serial.println', 'map', 'constrain',
                         'random', 'attachInterrupt', 'digitalPinToInterrupt'];
      functions.forEach(func => {
        const regex = new RegExp('\\b' + func.replace('.', '\\.') + '\\b', 'g');
        result = result.replace(regex, '<span class="code-function">$&</span>');
      });
      
      // Values
      result = result.replace(/\b(HIGH|LOW|OUTPUT|INPUT|INPUT_PULLUP|FALLING|RISING|CHANGE)\b/g, 
        '<span class="code-value">$&</span>');
      
      // Numbers
      result = result.replace(/\b(\d+)\b(?![\w-]*>)/g, 
        '<span class="code-number">$1</span>');
      
      return result;
    }

    // Update a code line
    function updateCodeLine(lineNum, value) {
      if (lineNum >= 0 && lineNum < codeLines.length) {
        codeLines[lineNum] = value;
        userCode[currentExercise] = codeLines.join('\n');
      }
    }

    // Configure pins on ESP32 board
    function configurePins(pinNumbers) {
      const pinsGrid = document.getElementById('pins-grid');
      if (!pinsGrid) return;
      
      pinsGrid.innerHTML = '';
      
      for (let i = 0; i < 20; i++) {
        const pin = document.createElement('div');
        const pinNum = i;
        
        pin.className = 'pin';
        pin.id = `pin-${pinNum}`;
        
        // Label
        const label = document.createElement('div');
        label.className = 'pin-label';
        label.textContent = `GPIO${pinNum}`;
        
        // Status
        const status = document.createElement('div');
        status.className = 'pin-status';
        status.id = `pin-status-${pinNum}`;
        
        // Check if pin is used
        if (pinNumbers.includes(pinNum)) {
          pin.classList.add('output');
          pin.dataset.mode = 'output';
          pin.dataset.state = 'low';
          status.textContent = 'OUT';
        } else {
          pin.dataset.mode = 'input';
          status.textContent = 'IN';
        }
        
        pin.appendChild(label);
        pin.appendChild(status);
        
        // Toggle mode on click
        pin.addEventListener('click', function() {
          togglePinMode(pinNum);
        });
        
        pinsGrid.appendChild(pin);
      }
    }

    // Toggle pin mode
    function togglePinMode(pinNum) {
      const pin = document.getElementById(`pin-${pinNum}`);
      const status = document.getElementById(`pin-status-${pinNum}`);
      
      if (!pin || !status) return;
      
      if (pin.dataset.mode === 'output') {
        pin.className = 'pin input';
        pin.dataset.mode = 'input';
        status.textContent = 'IN';
      } else {
        pin.className = 'pin output';
        pin.dataset.mode = 'output';
        pin.dataset.state = 'low';
        status.textContent = 'OUT';
      }
    }

    // Configure LEDs for exercise
    function configureExerciseLEDs(leds) {
      const ledsContainer = document.getElementById('leds-container');
      if (!ledsContainer) return;
      
      ledsContainer.innerHTML = '';
      
      leds.forEach(led => {
        const ledDiv = document.createElement('div');
        ledDiv.className = `led led-${led.color}`;
        ledDiv.id = `led-${led.id}`;
        
        // Pin label
        const pinLabel = document.createElement('div');
        pinLabel.className = 'led-connected-pin';
        pinLabel.textContent = `GPIO${led.pin}`;
        
        // LED label
        const ledLabel = document.createElement('div');
        ledLabel.className = 'led-label';
        ledLabel.textContent = `LED ${led.id}`;
        
        ledDiv.appendChild(pinLabel);
        ledDiv.appendChild(ledLabel);
        
        if (led.pwm || led.rgb) {
          ledDiv.dataset.pwm = 'true';
          ledDiv.dataset.brightness = '0';
        }
        
        ledsContainer.appendChild(ledDiv);
      });
    }
    function removeCommentsAndWhitespace(text) {
        if (!text) return '';
        
        // Enlever les commentaires sur une ligne
        let result = text.replace(/\/\/.*$/gm, '');
        
        // Enlever les commentaires multi-lignes
        result = result.replace(/\/\*[\s\S]*?\*\//g, '');
        
        // Enlever tous les espaces, tabulations et retours à la ligne
        result = result.replace(/\s/g, '');
        
        return result;
      }
      // Vérifier si le code est COMPLET pour l'exercice
function isExerciseComplete(code, exerciseNum) {
    const exercise = exercises[exerciseNum];
    if (!exercise) return false;
    
    const cleanCode = removeCommentsAndWhitespace(code);
    const cleanTemplate = removeCommentsAndWhitespace(exercise.template);
    const cleanSolution = removeCommentsAndWhitespace(exercise.solution);
    
    // Si le code est identique au template (même décommenté), c'est incomplet
    if (cleanCode === cleanTemplate) {
      return false;
    }
    
    // Si le code est identique à la solution, c'est complet
    if (cleanCode === cleanSolution) {
      return true;
    }
    
    // Vérifications spécifiques par exercice
    switch(exerciseNum) {
      case 1: // LED Clignotante
        // Doit avoir: pinMode, digitalWrite HIGH, digitalWrite LOW, delay deux fois
        const hasPinMode1 = /pinMode\s*\(\s*13\s*,\s*OUTPUT\s*\)/.test(cleanCode);
        const hasDigitalWriteHigh = /digitalWrite\s*\(\s*13\s*,\s*HIGH\s*\)/.test(cleanCode);
        const hasDigitalWriteLow = /digitalWrite\s*\(\s*13\s*,\s*LOW\s*\)/.test(cleanCode);
        const delayCount1 = (cleanCode.match(/delay\s*\(\s*\d+\s*\)/g) || []).length;
        const hasBothDigitalWrites = hasDigitalWriteHigh && hasDigitalWriteLow;
        
        return hasPinMode1 && hasBothDigitalWrites && delayCount1 >= 2;
        
      case 2: // Séquence LED
        const hasArray = /leds\s*\[\s*\]\s*=\s*\{.*\}/.test(cleanCode);
        const hasPinModeLoop = /for.*i.*<.*4.*pinMode.*leds\[i\]/.test(cleanCode);
        const hasDigitalWriteLoop = /for.*i.*<.*4.*digitalWrite.*leds\[i\]/.test(cleanCode);
        const hasDelay2 = /delay\s*\(\s*200\s*\)/.test(cleanCode);
        
        return hasArray && hasPinModeLoop && hasDigitalWriteLoop && hasDelay2;
        
      case 3: // PWM
        const hasAnalogWrite = /analogWrite\s*\(/.test(cleanCode);
        const hasBrightnessChange = /brightness.*[+\-]=/.test(cleanCode);
        const hasBoundaryCheck = /if\s*\(.*brightness.*[<>]=.*\d+.*\)/.test(cleanCode);
        const hasFadeAmountInversion = /fadeAmount\s*=\s*-\s*fadeAmount/.test(cleanCode);
        
        return hasAnalogWrite && hasBrightnessChange && hasBoundaryCheck && hasFadeAmountInversion;
        
      case 4: // RGB
        const hasSetColorFunction = /voidsetColor\(/.test(cleanCode);
        const analogWriteCount = (cleanCode.match(/analogWrite\(/g) || []).length;
        const hasColorCalls = /setColor\(255,0,0\)/.test(cleanCode) && 
                             /setColor\(0,255,0\)/.test(cleanCode) && 
                             /setColor\(0,0,255\)/.test(cleanCode);
        const delayCount4 = (cleanCode.match(/delay\(1000\)/g) || []).length;
        
        return hasSetColorFunction && analogWriteCount >= 3 && hasColorCalls && delayCount4 >= 3;
        
      case 5: // Feu tricolore
        const hasThreePins = /25.*26.*27/.test(cleanCode);
        const pinModeCount5 = (cleanCode.match(/pinMode\(/g) || []).length;
        const hasMillis = /millis\(/.test(cleanCode);
        const hasSwitchCase = /switch\(currentState\)/.test(cleanCode);
        const digitalWriteCount5 = (cleanCode.match(/digitalWrite\(/g) || []).length;
        
        return hasThreePins && pinModeCount5 >= 3 && hasMillis && hasSwitchCase && digitalWriteCount5 >= 6;
        
      case 6: // Animation complexe
        const hasMultiplePatterns = /patternCascade|patternBounce|patternRandom|patternAllBlink/.test(cleanCode);
        const hasMillis6 = /millis\(/.test(cleanCode);
        const hasForLoop = /for\(/.test(cleanCode);
        const hasPinModeLoop6 = /for.*i.*<.*numLeds.*pinMode.*leds\[i\]/.test(cleanCode);
        
        return hasMultiplePatterns && hasMillis6 && hasForLoop && hasPinModeLoop6;
        
      case 7: // LED avec bouton
        const hasPinMode7 = /pinMode\(13,OUTPUT\)/.test(cleanCode);
        const hasInputPullup = /INPUT_PULLUP/.test(cleanCode);
        const hasDigitalRead = /digitalRead\(/.test(cleanCode);
        const hasConditional = /if\(.*==.*LOW.*\)/.test(cleanCode);
        
        return hasPinMode7 && hasInputPullup && hasDigitalRead && hasConditional;
        
      case 8: // Potentiomètre
        const hasPinMode8 = /pinMode\(13,OUTPUT\)/.test(cleanCode);
        const hasAnalogRead = /analogRead\(/.test(cleanCode);
        const hasMap = /map\(/.test(cleanCode);
        const hasBlinkPattern = /digitalWrite\(13,HIGH\).*delay\(delayTime\).*digitalWrite\(13,LOW\).*delay\(delayTime\)/.test(cleanCode);
        
        return hasPinMode8 && hasAnalogRead && hasMap && hasBlinkPattern;
        
      case 9: // 2 boutons PWM
        const hasPinMode9 = /pinMode\(13,OUTPUT\)/.test(cleanCode);
        const hasAnalogWrite9 = /analogWrite\(/.test(cleanCode);
        const hasTwoDigitalReads = (cleanCode.match(/digitalRead\(/g) || []).length >= 2;
        const hasConstrains = /constrain\(/.test(cleanCode);
        const hasBrightnessAdjust = /brightness.*[+\-]=.*10/.test(cleanCode);
        
        return hasPinMode9 && hasAnalogWrite9 && hasTwoDigitalReads && hasConstrains && hasBrightnessAdjust;
        
      case 10: // Interruption
        const hasInterrupt = /attachInterrupt\(/.test(cleanCode);
        const hasVolatile = /volatile/.test(cleanCode);
        const hasMultiplePatterns10 = /pattern1|pattern2|pattern3/.test(cleanCode);
        const hasSwitchPattern = /switch\(pattern\)/.test(cleanCode);
        
        return hasInterrupt && hasVolatile && hasMultiplePatterns10 && hasSwitchPattern;
        
      default:
        // Pour les exercices non spécifiés, vérifier les bases
        const hasPinMode = /pinMode\(/.test(cleanCode);
        const hasDigitalWrite = /digitalWrite\(/.test(cleanCode);
        const hasDelay = /delay\(/.test(cleanCode);
        
        return hasPinMode && hasDigitalWrite && hasDelay;
    }
  }
  
    // Run user code with interpreter
// REMPLACER la fonction runCode() par cette version plus stricte :
// REMPLACER complètement la fonction runCode() par :
function runCode() {
    clearSerialMonitor();
    addSerialLine('⚡ Analyse approfondie du code...');
    addSerialLine('═══════════════════════════════');
    
    // Arrêter toute animation en cours
    if (simulationInterval) {
      clearInterval(simulationInterval);
      simulationInterval = null;
    }
    
    // Récupérer le code et l'exercice
    const code = userCode[currentExercise] || '';
    const exercise = exercises[currentExercise];
    
    if (!exercise) {
      addSerialLine('❌ ERREUR: Exercice non chargé');
      return;
    }
    
    // === VÉRIFICATION 1: Code non vide ===
    if (code.trim().length < 30) {
      addSerialLine('❌ Code trop court ou vide');
      addSerialLine('➡️  Écrivez du code Arduino valide dans les fonctions setup() et loop()');
      addSerialLine('➡️  Exemple minimal: pinMode(13, OUTPUT); digitalWrite(13, HIGH); delay(1000);');
      return;
    }
    
    // === VÉRIFICATION 2: Structure Arduino de base ===
    const hasSetup = code.includes('void setup()');
    const hasLoop = code.includes('void loop()');
    
    if (!hasSetup || !hasLoop) {
      addSerialLine('❌ Structure Arduino incorrecte');
      if (!hasSetup) addSerialLine('   • Fonction setup() manquante');
      if (!hasLoop) addSerialLine('   • Fonction loop() manquante');
      addSerialLine('➡️  Tous les programmes Arduino doivent avoir setup() et loop()');
      return;
    }
    
    // === VÉRIFICATION 3: Syntaxe correcte ===
    const syntaxErrors = validateArduinoSyntaxStrict(code);
    if (syntaxErrors.length > 0) {
      addSerialLine('❌ ERREURS DE SYNTAXE:');
      syntaxErrors.slice(0, 5).forEach(error => { // Limiter à 5 erreurs
        addSerialLine(`   • ${error}`);
      });
      if (syntaxErrors.length > 5) {
        addSerialLine(`   • ... et ${syntaxErrors.length - 5} autres erreurs`);
      }
      addSerialLine('═══════════════════════════════');
      addSerialLine('➡️  Corrigez la syntaxe avant de ré-exécuter');
      return;
    }
    // DANS runCode(), APRÈS la vérification de syntaxe, AJOUTER :
// === VÉRIFICATION 6: Vérification détaillée de l'exercice ===
const completeness = checkExerciseCompleteness(code, currentExercise);
const orderCheck = checkInstructionOrder(code, currentExercise);
const valueCheck = checkExactValues(code, currentExercise);

if (!completeness.complete) {
  addSerialLine('❌ CODE INCOMPLET POUR L\'EXERCICE');
  addSerialLine('═══════════════════════════════');
  addSerialLine(`Score: ${completeness.score}/100`);
  
  if (completeness.details.length > 0) {
    addSerialLine('Éléments corrects:');
    completeness.details.forEach(detail => {
      addSerialLine(`   ${detail}`);
    });
  }
  
  if (completeness.missing.length > 0) {
    addSerialLine('Éléments manquants:');
    completeness.missing.forEach(item => {
      addSerialLine(`   • ${item}`);
    });
  }
  
  // Afficher les problèmes d'ordre
  if (orderCheck.issues.length > 0) {
    addSerialLine('Problèmes d\'ordre:');
    orderCheck.issues.forEach(issue => {
      addSerialLine(`   ❌ ${issue}`);
    });
  }
  
  // Afficher les problèmes de valeurs
  if (valueCheck.issues.length > 0) {
    addSerialLine('Valeurs incorrectes:');
    valueCheck.issues.forEach(issue => {
      addSerialLine(`   ❌ ${issue}`);
    });
  }
  
  if (valueCheck.warnings.length > 0) {
    addSerialLine('Suggestions:');
    valueCheck.warnings.forEach(warning => {
      addSerialLine(`   💡 ${warning}`);
    });
  }
  
  addSerialLine('═══════════════════════════════');
  addSerialLine('➡️  Complétez votre code avant de continuer');
  
  // Mode apprentissage seulement
  if (completeness.score < 50) {
    addSerialLine('═══════════════════════════════');
    addSerialLine('❌ EXÉCUTION BLOQUÉE - Code trop incomplet');
    return;
  }
  
  addSerialLine('═══════════════════════════════');
  addSerialLine('⚠️  Exécution en mode apprentissage (code incomplet)...');
}
    // === VÉRIFICATION 4: Code vraiment modifié ===
    if (!isCodeTrulyModified(code, exercise.template)) {
      addSerialLine('❌ Code insuffisant ou identique au template');
      addSerialLine('➡️  Vous devez ÉCRIRE votre propre code Arduino');
      addSerialLine('➡️  Ne vous contentez pas de décommenter ou de copier-coller');
      
      // Afficher ce qui est attendu spécifiquement
      addSerialLine('═══════════════════════════════');
      addSerialLine('POUR CET EXERCICE (' + exercise.title + '):');
      addSerialLine('Vous devez implémenter:');
      
      const essentialFuncs = checkEssentialFunctions(code, currentExercise);
      if (!essentialFuncs.passed) {
        essentialFuncs.missing.forEach(func => {
          addSerialLine(`   • ${func.replace('(', '()')}`);
        });
      }
      
      if (currentExercise === 1) {
        addSerialLine('   • pinMode(13, OUTPUT) dans setup()');
        addSerialLine('   • digitalWrite(13, HIGH) pour allumer');
        addSerialLine('   • delay(1000) pour attendre 1 seconde');
        addSerialLine('   • digitalWrite(13, LOW) pour éteindre');
        addSerialLine('   • delay(1000) à nouveau');
      }
      
      return;
    }
    
    // === VÉRIFICATION 5: Code complet pour l'exercice ===
    const isComplete = isExerciseComplete(code, currentExercise);
    if (!isComplete) {
      addSerialLine('⚠️  Code incomplet pour cet exercice');
      addSerialLine('═══════════════════════════════');
      addSerialLine('Votre code fonctionne mais il manque des éléments:');
      
      // Analyse détaillée de ce qui manque
      const cleanCode = removeCommentsAndWhitespace(code);
      
      if (currentExercise === 1) {
        if (!/pinMode\s*\(\s*13\s*,\s*OUTPUT\s*\)/.test(cleanCode)) {
          addSerialLine('   • Configuration de la broche 13 en OUTPUT');
        }
        if (!/digitalWrite\s*\(\s*13\s*,\s*HIGH\s*\)/.test(cleanCode)) {
          addSerialLine('   • Allumage de la LED (digitalWrite(13, HIGH))');
        }
        if (!/digitalWrite\s*\(\s*13\s*,\s*LOW\s*\)/.test(cleanCode)) {
          addSerialLine('   • Extinction de la LED (digitalWrite(13, LOW))');
        }
        const delayCount = (cleanCode.match(/delay\s*\(\s*\d+\s*\)/g) || []).length;
        if (delayCount < 2) {
          addSerialLine('   • Deux appels à delay() pour les temporisations');
        }
      }
      
      addSerialLine('═══════════════════════════════');
      addSerialLine('➡️  Complétez votre code avant de vérifier la solution');
      addSerialLine('➡️  Utilisez "Vérifier la solution" pour une correction détaillée');
      
      // Malgré tout, exécuter le code partiel pour l'apprentissage
      addSerialLine('═══════════════════════════════');
      addSerialLine('Exécution partielle du code (mode apprentissage)...');
    } else {
      addSerialLine('✅ Code complet détecté!');
      addSerialLine('═══════════════════════════════');
      addSerialLine('Exécution du code...');
    }
    
    // === EXÉCUTION DU CODE ===
    const interpreter = new ArduinoInterpreter();
    const result = interpreter.execute(code);
    
    // === AFFICHAGE DES RÉSULTATS ===
    if (result.success) {
      addSerialLine('✅ Exécution terminée');
      addSerialLine('═══════════════════════════════');
      
      // Filtrer les messages significatifs
      const meaningfulOutput = result.output.filter(line => 
        line.startsWith('✓') || line.startsWith('❌') || line.startsWith('⚠')
      );
      
      if (meaningfulOutput.length > 0) {
        addSerialLine('Instructions exécutées:');
        meaningfulOutput.forEach(line => {
          addSerialLine(`  ${line}`);
        });
      } else {
        addSerialLine('⚠️  Aucune instruction Arduino significative exécutée');
      }
      
      // Mise à jour de la visualisation
      updateVisualizationFromInterpreter(interpreter, exercise);
      
      // Démarrer l'animation seulement si le code est complet
      if (isComplete) {
        const hasMeaningfulOps = result.output.some(line => 
          line.startsWith('✓ pinMode') || 
          line.startsWith('✓ digitalWrite') || 
          line.startsWith('✓ analogWrite')
        );
        
        if (hasMeaningfulOps) {
          startSmartAnimation(exercise, interpreter);
        }
      } else {
        addSerialLine('[MODE APPRENTISSAGE] Animation désactivée - code incomplet');
      }
    } else {
      addSerialLine('❌ Exécution échouée');
      addSerialLine('═══════════════════════════════');
      
      if (result.error) {
        addSerialLine(`Erreur: ${result.error}`);
      }
      
      // Afficher les erreurs spécifiques
      const errorMessages = result.output.filter(line => line.includes('❌'));
      if (errorMessages.length > 0) {
        addSerialLine('Problèmes détectés:');
        errorMessages.forEach(msg => {
          addSerialLine(`  ${msg}`);
        });
      }
      
      addSerialLine('═══════════════════════════════');
      addSerialLine('➡️  Corrigez les erreurs et ré-exécutez');
    }
    
    // === CONSEIL FINAL ===
    if (!isComplete && currentExercise === 1) {
      addSerialLine('═══════════════════════════════');
      addSerialLine('💡 CONSEIL pour l\'exercice 1:');
      addSerialLine('Un programme LED clignotante complet doit avoir:');
      addSerialLine('1. pinMode(13, OUTPUT) dans setup()');
      addSerialLine('2. digitalWrite(13, HIGH) pour allumer');
      addSerialLine('3. delay(1000) pour attendre');
      addSerialLine('4. digitalWrite(13, LOW) pour éteindre');
      addSerialLine('5. delay(1000) pour attendre à nouveau');
      addSerialLine('6. Tout cela dans une boucle loop() infinie');
    }
  } 
  // AJOUTER ces nouvelles fonctions de validation :
  
  // Validation syntaxique STRICTE
 // Vérifier la syntaxe Arduino de manière stricte
function validateArduinoSyntaxStrict(code) {
    const errors = [];
    const lines = code.split('\n');
    
    lines.forEach((line, index) => {
      const trimmed = line.trim();
      const lineNum = index + 1;
      
      // Ignorer les lignes vides et commentaires
      if (!trimmed || trimmed.startsWith('//')) return;
      
      // Vérifier les parenthèses fermantes manquantes
      if (trimmed.includes('(') && !trimmed.includes(')') && !trimmed.includes('//')) {
        // Sauf pour les déclarations de fonctions
        if (!trimmed.match(/void\s+\w+\s*\([^)]*$/)) {
          errors.push(`Ligne ${lineNum}: Parenthèse fermante manquante dans "${trimmed.substring(0, 30)}..."`);
        }
      }
      
      // Vérifier les points-virgules manquants
      if (trimmed && 
          !trimmed.endsWith(';') && 
          !trimmed.endsWith('{') && 
          !trimmed.endsWith('}') &&
          !trimmed.match(/^[{}]$/) &&
          !trimmed.startsWith('#') &&
          !trimmed.match(/^\/\//) &&
          !trimmed.match(/^void\s+\w+\s*\(.*\)\s*$/) &&
          !trimmed.match(/^for\s*\(.*\)\s*$/) &&
          !trimmed.match(/^if\s*\(.*\)\s*$/) &&
          !trimmed.match(/^while\s*\(.*\)\s*$/) &&
          !trimmed.match(/^else\s*$/) &&
          !trimmed.match(/^switch\s*\(.*\)\s*$/)) {
        
        // Vérifier si c'est une instruction qui devrait se terminer par ;
        const hasAssignment = trimmed.match(/^\w+\s*[=+\-*/]/);
        const hasFunctionCall = trimmed.match(/\w+\s*\(/);
        
        if (hasAssignment || hasFunctionCall) {
          errors.push(`Ligne ${lineNum}: Point-virgule manquant (;)`);
        }
      }
      
      // Vérifier les fonctions Arduino mal écrites
      const commonTypos = [
        { wrong: 'Mode(', correct: 'pinMode(' },
        { wrong: 'DigitalWrite(', correct: 'digitalWrite(' },
        { wrong: 'AnalogWrite(', correct: 'analogWrite(' },
        { wrong: 'DigitalRead(', correct: 'digitalRead(' },
        { wrong: 'AnalogRead(', correct: 'analogRead(' }
      ];
      
      commonTypos.forEach(typo => {
        if (trimmed.includes(typo.wrong) && !trimmed.includes(typo.correct)) {
          errors.push(`Ligne ${lineNum}: "${typo.wrong}" → "${typo.correct}"`);
        }
      });
      
      // Vérifier les paramètres incomplets
      if (trimmed.includes('digitalWrite(')) {
        const match = trimmed.match(/digitalWrite\s*\(\s*([^,)]+)\s*,?\s*([^)]*)?\s*\)?/);
        if (match) {
          const secondParam = match[2] ? match[2].trim() : '';
          if (!secondParam || (secondParam !== 'HIGH' && secondParam !== 'LOW')) {
            errors.push(`Ligne ${lineNum}: digitalWrite() nécessite 2 paramètres: pin et HIGH/LOW`);
          }
        }
      }
      
      if (trimmed.includes('analogWrite(')) {
        const match = trimmed.match(/analogWrite\s*\(\s*([^,)]+)\s*,?\s*([^)]*)?\s*\)?/);
        if (match) {
          const secondParam = match[2] ? match[2].trim() : '';
          if (!secondParam) {
            errors.push(`Ligne ${lineNum}: analogWrite() nécessite 2 paramètres: pin et valeur (0-255)`);
          } else {
            const value = parseInt(secondParam);
            if (isNaN(value) || value < 0 || value > 255) {
              errors.push(`Ligne ${lineNum}: analogWrite() valeur doit être entre 0 et 255`);
            }
          }
        }
      }
      
      if (trimmed.includes('delay(')) {
        const match = trimmed.match(/delay\s*\(\s*([^)]+)\s*\)/);
        if (!match) {
          errors.push(`Ligne ${lineNum}: delay() mal formé. Exemple: delay(1000)`);
        }
      }
    });
    
    // Vérifier la structure de base
    const hasSetup = code.includes('void setup()');
    const hasLoop = code.includes('void loop()');
    
    if (!hasSetup) {
      errors.push("Fonction setup() manquante");
    }
    if (!hasLoop) {
      errors.push("Fonction loop() manquante");
    }
    
    return errors;
  }
  // Vérifier les fonctions essentielles par exercice
  function checkEssentialFunctions(code, exerciseNum) {
    const requirements = {
      1: ['pinMode(', 'digitalWrite(', 'delay('],
      2: ['pinMode(', 'digitalWrite(', 'delay(', 'for('],
      3: ['analogWrite(', 'delay('],
      4: ['analogWrite(', 'delay(', 'setColor('],
      5: ['pinMode(', 'digitalWrite(', 'millis(', 'switch('],
      6: ['pinMode(', 'digitalWrite(', 'millis(', 'for('],
      7: ['pinMode(', 'digitalWrite(', 'digitalRead(', 'INPUT_PULLUP'],
      8: ['pinMode(', 'digitalWrite(', 'analogRead(', 'map(', 'delay('],
      9: ['pinMode(', 'analogWrite(', 'digitalRead(', 'constrain(', 'delay('],
      10: ['pinMode(', 'digitalWrite(', 'attachInterrupt(', 'volatile', 'delay(']
    };
    
    const exerciseReqs = requirements[exerciseNum] || [];
    const missing = [];
    
    exerciseReqs.forEach(req => {
      if (!code.includes(req)) {
        missing.push(req);
      }
    });
    
    return {
      passed: missing.length === 0,
      missing: missing
    };
  }
    // Update visualization based on interpreter results
    function updateVisualizationFromInterpreter(interpreter, exercise) {
      // Reset everything
      document.querySelectorAll('.led').forEach(led => {
        led.classList.remove('on');
        led.style.opacity = '1';
        led.style.backgroundColor = '';
      });
      
      document.querySelectorAll('.pin').forEach(pin => {
        pin.classList.remove('active');
      });
      
      // Update based on pin states
      exercise.leds.forEach(led => {
        const ledElement = document.getElementById(`led-${led.id}`);
        const pinElement = document.getElementById(`pin-${led.pin}`);
        
        if (ledElement && pinElement) {
          const pinState = interpreter.getPinState(led.pin);
          
          if (pinState > 0) {
            ledElement.classList.add('on');
            pinElement.classList.add('active');
            
            // PWM brightness
            if (led.pwm) {
              const brightness = Math.min(1, Math.max(0, pinState));
              ledElement.style.opacity = brightness;
            }
            
            // RGB
            if (led.rgb) {
              const r = Math.round((interpreter.getPinState(led.pin) || 0) * 255);
              const g = Math.round((interpreter.getPinState(led.pin + 1) || 0) * 255);
              const b = Math.round((interpreter.getPinState(led.pin + 2) || 0) * 255);
              
              ledElement.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
            }
          }
        }
      });
    }

    // Smart animation based on interpreter results
    function startSmartAnimation(exercise, interpreter) {
      if (simulationInterval) {
        clearInterval(simulationInterval);
        simulationInterval = null;
      }
      
      const code = userCode[currentExercise] || '';
      
      // Don't animate if there are errors
      if (interpreter.hasErrors) {
        addSerialLine('[ANIM] Animation désactivée: erreurs dans le code');
        return;
      }
      
      // Choose animation based on exercise
      switch(currentExercise) {
        case 1: // LED clignotante
          startBlinkAnimation(exercise);
          break;
        case 2: // Séquence LED
          startChaseAnimation(exercise);
          break;
        case 3: // PWM
          startPWMAnimation(exercise);
          break;
        case 4: // RGB
          startRGBAnimation(exercise);
          break;
        case 5: // Feu tricolore
          startTrafficLightAnimation(exercise);
          break;
        case 6: // Animation complexe
          startComplexAnimation(exercise);
          break;
        case 7: // LED avec bouton
          startButtonLEDAnimation(exercise);
          break;
        case 8: // Potentiomètre
          startPotentiometerAnimation(exercise);
          break;
        case 9: // 2 boutons PWM
          startTwoButtonsAnimation(exercise);
          break;
        case 10: // Interruption
          startInterruptAnimation(exercise);
          break;
        default:
          startGenericAnimation(exercise);
      }
    }

    // Animation for Exercise 1
    function startBlinkAnimation(exercise) {
      const led = document.getElementById('led-1');
      const pin = document.getElementById('pin-13');
      
      if (!led || !pin) return;
      
      let state = false;
      
      simulationInterval = setInterval(() => {
        state = !state;
        
        if (state) {
          led.classList.add('on');
          pin.classList.add('active');
          addSerialLine('[ANIM] LED allumée');
        } else {
          led.classList.remove('on');
          pin.classList.remove('active');
          addSerialLine('[ANIM] LED éteinte');
        }
      }, 1000);
      
      addSerialLine('[ANIM] Animation LED clignotante démarrée');
    }

    // Animation for Exercise 2
    function startChaseAnimation(exercise) {
      let currentIndex = 0;
      
      simulationInterval = setInterval(() => {
        // Turn off all LEDs
        exercise.leds.forEach((led, idx) => {
          const ledEl = document.getElementById(`led-${led.id}`);
          const pinEl = document.getElementById(`pin-${led.pin}`);
          
          if (ledEl) ledEl.classList.remove('on');
          if (pinEl) pinEl.classList.remove('active');
        });
        
        // Turn on current LED
        const currentLED = exercise.leds[currentIndex];
        if (currentLED) {
          const ledEl = document.getElementById(`led-${currentLED.id}`);
          const pinEl = document.getElementById(`pin-${currentLED.pin}`);
          
          if (ledEl) ledEl.classList.add('on');
          if (pinEl) pinEl.classList.add('active');
          
          addSerialLine(`[ANIM] LED ${currentIndex + 1} allumée`);
        }
        
        // Move to next LED
        currentIndex = (currentIndex + 1) % exercise.leds.length;
      }, 300);
      
      addSerialLine('[ANIM] Animation séquence LED démarrée');
    }

    // Animation for Exercise 3
    function startPWMAnimation(exercise) {
      let brightness = 0;
      let direction = 5;
      
      simulationInterval = setInterval(() => {
        brightness += direction;
        
        if (brightness >= 255) {
          brightness = 255;
          direction = -5;
          addSerialLine('[ANIM] Maximum luminosité');
        } else if (brightness <= 0) {
          brightness = 0;
          direction = 5;
          addSerialLine('[ANIM] LED éteinte');
        }
        
        const led = document.getElementById('led-1');
        const pin = document.getElementById('pin-15');
        
        if (led) {
          const opacity = brightness / 255;
          led.style.opacity = opacity;
          
          if (brightness > 0) {
            led.classList.add('on');
          } else {
            led.classList.remove('on');
          }
        }
        
        if (pin) {
          if (brightness > 0) {
            pin.classList.add('active');
          } else {
            pin.classList.remove('active');
          }
        }
      }, 50);
      
      addSerialLine('[ANIM] Animation PWM démarrée');
    }

    // Animation for Exercise 4
    function startRGBAnimation(exercise) {
      const colors = [
        {name: "Rouge", r: 255, g: 0, b: 0},
        {name: "Vert", r: 0, g: 255, b: 0},
        {name: "Bleu", r: 0, g: 0, b: 255}
      ];
      
      let currentColor = 0;
      
      simulationInterval = setInterval(() => {
        const color = colors[currentColor];
        const led = document.getElementById('led-1');
        
        if (led) {
          led.style.backgroundColor = `rgb(${color.r}, ${color.g}, ${color.b})`;
          led.classList.add('on');
          
          // Update pins
          [12, 13, 14].forEach(pinNum => {
            const pin = document.getElementById(`pin-${pinNum}`);
            if (pin) {
              if ((pinNum === 12 && color.r > 0) || 
                  (pinNum === 13 && color.g > 0) || 
                  (pinNum === 14 && color.b > 0)) {
                pin.classList.add('active');
              } else {
                pin.classList.remove('active');
              }
            }
          });
          
          addSerialLine(`[ANIM] ${color.name}`);
        }
        
        currentColor = (currentColor + 1) % colors.length;
      }, 1500);
      
      addSerialLine('[ANIM] Animation RGB démarrée');
    }

    // Animation for Exercise 5
    function startTrafficLightAnimation(exercise) {
      const states = [
        {red: true, yellow: false, green: false, duration: 3000, name: "Rouge"},
        {red: true, yellow: true, green: false, duration: 1000, name: "Rouge+Jaune"},
        {red: false, yellow: false, green: true, duration: 3000, name: "Vert"},
        {red: false, yellow: true, green: false, duration: 1000, name: "Jaune"}
      ];
      
      let currentState = 0;
      let lastChange = Date.now();
      
      simulationInterval = setInterval(() => {
        const now = Date.now();
        
        if (now - lastChange >= states[currentState].duration) {
          lastChange = now;
          currentState = (currentState + 1) % states.length;
          addSerialLine(`[ANIM] ${states[currentState].name}`);
        }
        
        // Update LEDs
        exercise.leds.forEach(led => {
          const ledEl = document.getElementById(`led-${led.id}`);
          const pinEl = document.getElementById(`pin-${led.pin}`);
          
          if (ledEl && pinEl) {
            const state = states[currentState];
            let shouldBeOn = false;
            
            if (led.color === 'red') shouldBeOn = state.red;
            else if (led.color === 'yellow') shouldBeOn = state.yellow;
            else if (led.color === 'green') shouldBeOn = state.green;
            
            if (shouldBeOn) {
              ledEl.classList.add('on');
              pinEl.classList.add('active');
            } else {
              ledEl.classList.remove('on');
              pinEl.classList.remove('active');
            }
          }
        });
      }, 100);
      
      addSerialLine('[ANIM] Animation feu tricolore démarrée');
    }

    // Animation for Exercise 6
    function startComplexAnimation(exercise) {
      let pattern = 0;
      let animationState = 0;
      let lastPatternChange = Date.now();
      
      simulationInterval = setInterval(() => {
        const now = Date.now();
        
        // Change pattern every 5 seconds
        if (now - lastPatternChange >= 5000) {
          pattern = (pattern + 1) % 4;
          lastPatternChange = now;
          animationState = 0;
          addSerialLine(`[ANIM] Pattern ${pattern + 1}`);
        }
        
        // Update based on pattern
        exercise.leds.forEach((led, idx) => {
          const ledEl = document.getElementById(`led-${led.id}`);
          const pinEl = document.getElementById(`pin-${led.pin}`);
          
          if (ledEl && pinEl) {
            let shouldBeOn = false;
            
            switch(pattern) {
              case 0: // Cascade
                shouldBeOn = (idx === animationState % 6);
                break;
              case 1: // Bounce
                const bounceIndex = animationState % 10;
                const actualIndex = bounceIndex < 5 ? bounceIndex : 9 - bounceIndex;
                shouldBeOn = (idx === actualIndex);
                break;
              case 2: // Random
                shouldBeOn = Math.random() > 0.5;
                break;
              case 3: // All blink
                shouldBeOn = animationState % 2 === 0;
                break;
            }
            
            if (shouldBeOn) {
              ledEl.classList.add('on');
              pinEl.classList.add('active');
            } else {
              ledEl.classList.remove('on');
              pinEl.classList.remove('active');
            }
          }
        });
        
        animationState++;
      }, 200);
      
      addSerialLine('[ANIM] Animation complexe démarrée');
    }

    // Animation for Exercise 7
    function startButtonLEDAnimation(exercise) {
      let buttonPressed = false;
      
      simulationInterval = setInterval(() => {
        // Simulate random button presses
        if (Math.random() > 0.8) {
          buttonPressed = !buttonPressed;
          addSerialLine(`[ANIM] Bouton ${buttonPressed ? 'pressé' : 'relâché'}`);
        }
        
        const led = document.getElementById('led-1');
        const pin = document.getElementById('pin-13');
        const buttonPin = document.getElementById('pin-12');
        
        if (led && pin && buttonPin) {
          if (buttonPressed) {
            led.classList.add('on');
            pin.classList.add('active');
            buttonPin.classList.add('active');
          } else {
            led.classList.remove('on');
            pin.classList.remove('active');
            buttonPin.classList.remove('active');
          }
        }
      }, 500);
      
      addSerialLine('[ANIM] Animation bouton+LED démarrée');
    }

    // Animation for Exercise 8
    function startPotentiometerAnimation(exercise) {
      let potValue = 512;
      let direction = 1;
      
      simulationInterval = setInterval(() => {
        potValue += direction * 100;
        
        if (potValue >= 4095) {
          potValue = 4095;
          direction = -1;
        } else if (potValue <= 0) {
          potValue = 0;
          direction = 1;
        }
        
        const delayTime = Math.floor(mapValue(potValue, 0, 4095, 50, 1000));
        const led = document.getElementById('led-1');
        const pin = document.getElementById('pin-13');
        
        if (led && pin) {
          // Toggle LED based on delay
          let state = led.classList.contains('on');
          if (!state) {
            led.classList.add('on');
            pin.classList.add('active');
          } else {
            setTimeout(() => {
              led.classList.remove('on');
              pin.classList.remove('active');
            }, delayTime / 2);
          }
        }
      }, 300);
      
      addSerialLine('[ANIM] Animation potentiomètre démarrée');
    }
    
    function mapValue(value, inMin, inMax, outMin, outMax) {
      return (value - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;
    }

    // Animation for Exercise 9
    function startTwoButtonsAnimation(exercise) {
      let brightness = 128;
      let direction = 1;
      
      simulationInterval = setInterval(() => {
        // Simulate button presses
        if (Math.random() > 0.7) {
          brightness += direction * 10;
          
          if (brightness >= 255) {
            brightness = 255;
            direction = -1;
            addSerialLine('[ANIM] Bouton - pressé');
          } else if (brightness <= 0) {
            brightness = 0;
            direction = 1;
            addSerialLine('[ANIM] Bouton + pressé');
          }
        }
        
        const led = document.getElementById('led-1');
        const pin = document.getElementById('pin-13');
        
        if (led && pin) {
          const opacity = brightness / 255;
          led.style.opacity = opacity;
          
          if (brightness > 0) {
            led.classList.add('on');
            pin.classList.add('active');
          } else {
            led.classList.remove('on');
            pin.classList.remove('active');
          }
        }
      }, 500);
      
      addSerialLine('[ANIM] Animation 2 boutons PWM démarrée');
    }

    // Animation for Exercise 10
    function startInterruptAnimation(exercise) {
      let pattern = 0;
      let ledIndex = 0;
      let lastChange = Date.now();
      
      simulationInterval = setInterval(() => {
        const now = Date.now();
        
        // Simulate interrupt every 5 seconds
        if (now - lastChange > 5000) {
          pattern = (pattern + 1) % 3;
          lastChange = now;
          ledIndex = 0;
          addSerialLine(`[ANIM] Interruption! Pattern ${pattern + 1}`);
        }
        
        // Update LEDs based on pattern
        exercise.leds.forEach((led, idx) => {
          const ledEl = document.getElementById(`led-${led.id}`);
          const pinEl = document.getElementById(`pin-${led.pin}`);
          
          if (ledEl && pinEl) {
            let shouldBeOn = false;
            
            switch(pattern) {
              case 0: // Simple sequence
                shouldBeOn = (idx === ledIndex);
                break;
              case 1: // Reverse sequence
                shouldBeOn = (idx === (3 - ledIndex));
                break;
              case 2: // Group blink
                shouldBeOn = (idx % 2 === ledIndex % 2);
                break;
            }
            
            if (shouldBeOn) {
              ledEl.classList.add('on');
              pinEl.classList.add('active');
            } else {
              ledEl.classList.remove('on');
              pinEl.classList.remove('active');
            }
          }
        });
        
        ledIndex = (ledIndex + 1) % 4;
      }, 300);
      
      addSerialLine('[ANIM] Animation interruption démarrée');
    }

    // Generic animation
    function startGenericAnimation(exercise) {
      let state = false;
      
      simulationInterval = setInterval(() => {
        state = !state;
        
        exercise.leds.forEach(led => {
          const ledEl = document.getElementById(`led-${led.id}`);
          const pinEl = document.getElementById(`pin-${led.pin}`);
          
          if (ledEl && pinEl) {
            if (state) {
              ledEl.classList.add('on');
              pinEl.classList.add('active');
            } else {
              ledEl.classList.remove('on');
              pinEl.classList.remove('active');
            }
          }
        });
        
        addSerialLine(state ? '[ANIM] LEDs allumées' : '[ANIM] LEDs éteintes');
      }, 1000);
      
      addSerialLine('[ANIM] Animation générique démarrée');
    }

    // Reset simulation
    function resetSimulation() {
      if (simulationInterval) {
        clearInterval(simulationInterval);
        simulationInterval = null;
      }
      
      // Turn off all LEDs
      document.querySelectorAll('.led').forEach(led => {
        led.classList.remove('on');
        led.style.opacity = '1';
        led.style.backgroundColor = '';
      });
      
      // Reset pins
      document.querySelectorAll('.pin').forEach(pin => {
        pin.classList.remove('active');
      });
      
      // Clear serial monitor
      clearSerialMonitor();
      addSerialLine('Simulation réinitialisée');
    }

    // 1. Vérifier l'ordre des instructions (pour exercices où c'est important)
// FONCTION COMPLÈTE - PRÊTE À COPIER-COLLER
function checkInstructionOrder(code, exerciseNum) {
    const lines = code.split('\n');
    const results = {
      hasCorrectOrder: false,
      issues: [],
      orderDetails: [],
      warnings: []
    };
    
    // Filtrer les lignes significatives
    const meaningfulLines = lines.filter(line => {
      const trimmed = line.trim();
      return trimmed && 
             !trimmed.startsWith('//') && 
             !trimmed.startsWith('/*') &&
             !trimmed.startsWith('* ') &&
             trimmed !== '{' && 
             trimmed !== '}';
    });
    
    // Exercice 1: LED Clignotante - HIGH d'abord, puis LOW
    if (exerciseNum === 1) {
      let highIndex = -1;
      let lowIndex = -1;
      let highCount = 0;
      let lowCount = 0;
      
      meaningfulLines.forEach((line, index) => {
        if (line.includes('digitalWrite(13, HIGH)')) {
          highIndex = index;
          highCount++;
        }
        if (line.includes('digitalWrite(13, LOW)')) {
          lowIndex = index;
          lowCount++;
        }
      });
      
      if (highCount === 0) {
        results.issues.push("digitalWrite(13, HIGH) manquant - vous devez allumer la LED");
      }
      if (lowCount === 0) {
        results.issues.push("digitalWrite(13, LOW) manquant - vous devez éteindre la LED");
      }
      if (highCount > 0 && lowCount > 0) {
        if (highIndex < lowIndex) {
          results.hasCorrectOrder = true;
          results.orderDetails.push("✓ Ordre correct: HIGH avant LOW (allumer puis éteindre)");
        } else {
          results.issues.push("ORDRE INCORRECT: Vous éteignez (LOW) avant d'allumer (HIGH) - l'exercice demande d'allumer d'abord");
          results.orderDetails.push("✗ Problème d'ordre: LOW avant HIGH");
        }
      }
    }
    
    // Exercice 2: Séquence LED - dans l'ordre du tableau
    else if (exerciseNum === 2) {
      let hasSequentialDigitalWrites = false;
      let digitalWriteCount = 0;
      
      meaningfulLines.forEach(line => {
        if (line.includes('digitalWrite(leds[')) {
          digitalWriteCount++;
        }
      });
      
      if (digitalWriteCount >= 2) {
        hasSequentialDigitalWrites = true;
        results.orderDetails.push("✓ Contrôle séquentiel des LEDs détecté");
      } else if (digitalWriteCount === 1) {
        results.issues.push("Besoin de contrôler plusieurs LEDs en séquence, pas une seule");
      }
      
      // Vérifier si c'est dans une boucle
      let inForLoop = false;
      let currentIndent = 0;
      
      meaningfulLines.forEach(line => {
        if (line.includes('for(') && line.includes('i++')) {
          inForLoop = true;
          currentIndent = line.indexOf('for');
        }
        if (inForLoop && line.includes('digitalWrite(') && line.indexOf('digitalWrite') > currentIndent) {
          results.orderDetails.push("✓ digitalWrite() dans une boucle for");
        }
      });
      
      results.hasCorrectOrder = hasSequentialDigitalWrites && digitalWriteCount >= 2;
    }
    
    // Exercice 3: PWM - analogWrite avant modification de brightness
    else if (exerciseNum === 3) {
      let analogWriteIndex = -1;
      let brightnessChangeIndex = -1;
      let boundaryCheckIndex = -1;
      
      meaningfulLines.forEach((line, index) => {
        if (line.includes('analogWrite(')) {
          analogWriteIndex = index;
        }
        if (line.includes('brightness =') || line.includes('brightness +=') || line.includes('brightness -=')) {
          brightnessChangeIndex = index;
        }
        if (line.includes('brightness <= 0') || line.includes('brightness >= 255')) {
          boundaryCheckIndex = index;
        }
      });
      
      if (analogWriteIndex !== -1) {
        results.orderDetails.push(`✓ analogWrite() détecté`);
      } else {
        results.issues.push("analogWrite() manquant pour le contrôle PWM");
      }
      
      if (brightnessChangeIndex !== -1) {
        results.orderDetails.push(`✓ Modification de brightness détectée`);
      } else {
        results.issues.push("Modification de la variable brightness manquante");
      }
      
      if (boundaryCheckIndex !== -1) {
        results.orderDetails.push(`✓ Vérification des limites (0-255) détectée`);
      } else {
        results.issues.push("Vérification des limites brightness (0 ou 255) manquante");
      }
      
      // Pour PWM, l'ordre est: analogWrite → brightness change → boundary check
      if (analogWriteIndex !== -1 && brightnessChangeIndex !== -1) {
        if (analogWriteIndex < brightnessChangeIndex) {
          results.orderDetails.push("✓ Ordre logique: analogWrite avant modification brightness");
          results.hasCorrectOrder = true;
        } else {
          results.warnings.push("Modifiez brightness avant d'appliquer analogWrite()");
        }
      }
    }
    
    // Exercice 4: RGB - setColor défini avant d'être utilisé
    else if (exerciseNum === 4) {
      let setColorDefIndex = -1;
      let setColorUseIndex = -1;
      let hasAnalogWriteInSetColor = false;
      
      meaningfulLines.forEach((line, index) => {
        if (line.includes('void setColor(')) {
          setColorDefIndex = index;
        }
        if (line.includes('setColor(') && !line.includes('void setColor')) {
          setColorUseIndex = index;
        }
        if (line.includes('analogWrite(') && index > setColorDefIndex && setColorDefIndex !== -1) {
          hasAnalogWriteInSetColor = true;
        }
      });
      
      if (setColorDefIndex !== -1) {
        results.orderDetails.push("✓ Fonction setColor() définie");
      } else {
        results.issues.push("Fonction setColor() manquante pour contrôler les couleurs RGB");
      }
      
      if (setColorUseIndex !== -1) {
        results.orderDetails.push("✓ Appel de setColor() détecté");
      } else {
        results.issues.push("Appel de setColor() manquant dans loop()");
      }
      
      if (hasAnalogWriteInSetColor) {
        results.orderDetails.push("✓ analogWrite() dans setColor()");
      }
      
      // L'ordre correct: définition setColor avant son utilisation
      if (setColorDefIndex !== -1 && setColorUseIndex !== -1) {
        if (setColorDefIndex < setColorUseIndex) {
          results.hasCorrectOrder = true;
          results.orderDetails.push("✓ Ordre correct: définition setColor avant utilisation");
        } else {
          results.issues.push("Définissez setColor() avant de l'utiliser dans loop()");
        }
      }
    }
    
    // Exercice 5: Feu tricolore - ordre des états: 0→1→2→3
    else if (exerciseNum === 5) {
      const states = ['case 0:', 'case 1:', 'case 2:', 'case 3:'];
      let stateOrder = [];
      let stateLines = {};
      
      meaningfulLines.forEach((line, index) => {
        states.forEach(state => {
          if (line.includes(state)) {
            stateOrder.push(state);
            stateLines[state] = index;
          }
        });
      });
      
      if (stateOrder.length >= 4) {
        const isCorrectOrder = stateOrder[0] === 'case 0:' && 
                              stateOrder[1] === 'case 1:' && 
                              stateOrder[2] === 'case 2:' && 
                              stateOrder[3] === 'case 3:';
        
        if (isCorrectOrder) {
          results.hasCorrectOrder = true;
          results.orderDetails.push("✓ Ordre des états correct: Rouge → Rouge+Jaune → Vert → Jaune");
        } else {
          results.issues.push("Ordre des états incorrect. Doit être: case 0 (rouge) → case 1 (rouge+jaune) → case 2 (vert) → case 3 (jaune)");
        }
      } else if (stateOrder.length > 0) {
        results.issues.push(`Seulement ${stateOrder.length}/4 états définis pour le feu tricolore`);
      } else {
        results.issues.push("Structure switch/case manquante pour les états du feu");
      }
    }
    
    // Exercice 6: Animation complexe - patterns définis avant switch
    else if (exerciseNum === 6) {
      let patternDefs = [];
      let switchIndex = -1;
      
      meaningfulLines.forEach((line, index) => {
        if (line.includes('void pattern')) {
          patternDefs.push({ name: line.match(/void\s+(\w+)/)[1], index: index });
        }
        if (line.includes('switch(pattern)')) {
          switchIndex = index;
        }
      });
      
      if (patternDefs.length >= 2) {
        results.orderDetails.push(`✓ ${patternDefs.length} fonctions pattern définies`);
      } else {
        results.issues.push("Besoin d'au moins 2 fonctions pattern (patternCascade, patternBounce, etc.)");
      }
      
      if (switchIndex !== -1) {
        results.orderDetails.push("✓ Structure switch(pattern) détectée");
      } else {
        results.issues.push("Structure switch(pattern) manquante pour changer entre patterns");
      }
      
      // Vérifier que les patterns sont définis avant le switch
      let allDefinedBeforeSwitch = true;
      patternDefs.forEach(pattern => {
        if (pattern.index > switchIndex) {
          allDefinedBeforeSwitch = false;
          results.warnings.push(`Définissez ${pattern.name}() avant switch(pattern)`);
        }
      });
      
      results.hasCorrectOrder = patternDefs.length >= 2 && switchIndex !== -1 && allDefinedBeforeSwitch;
    }
    
    // Exercice 7: LED avec bouton - digitalRead avant if
    else if (exerciseNum === 7) {
      let digitalReadIndex = -1;
      let ifStatementIndex = -1;
      let hasInputPullup = false;
      
      meaningfulLines.forEach((line, index) => {
        if (line.includes('digitalRead(')) {
          digitalReadIndex = index;
        }
        if (line.includes('if(') && (line.includes('LOW') || line.includes('HIGH'))) {
          ifStatementIndex = index;
        }
        if (line.includes('INPUT_PULLUP')) {
          hasInputPullup = true;
        }
      });
      
      if (digitalReadIndex !== -1) {
        results.orderDetails.push("✓ digitalRead() détecté");
      } else {
        results.issues.push("digitalRead() manquant pour lire l'état du bouton");
      }
      
      if (ifStatementIndex !== -1) {
        results.orderDetails.push("✓ Condition if() détectée");
      } else {
        results.issues.push("Condition if() manquante pour réagir au bouton");
      }
      
      if (hasInputPullup) {
        results.orderDetails.push("✓ INPUT_PULLUP utilisé pour le bouton");
      } else {
        results.issues.push("Utilisez INPUT_PULLUP pour la configuration du bouton");
      }
      
      // Ordre: digitalRead puis if
      if (digitalReadIndex !== -1 && ifStatementIndex !== -1) {
        if (digitalReadIndex < ifStatementIndex) {
          results.hasCorrectOrder = true;
          results.orderDetails.push("✓ Ordre correct: lecture bouton avant condition");
        } else {
          results.warnings.push("Placez digitalRead() avant la condition if()");
        }
      }
    }
    
    // Exercice 8: Potentiomètre - analogRead avant map
    else if (exerciseNum === 8) {
      let analogReadIndex = -1;
      let mapIndex = -1;
      let delayTimeIndex = -1;
      
      meaningfulLines.forEach((line, index) => {
        if (line.includes('analogRead(')) {
          analogReadIndex = index;
        }
        if (line.includes('map(')) {
          mapIndex = index;
        }
        if (line.includes('delayTime')) {
          delayTimeIndex = index;
        }
      });
      
      if (analogReadIndex !== -1) {
        results.orderDetails.push("✓ analogRead() détecté");
      } else {
        results.issues.push("analogRead() manquant pour lire le potentiomètre");
      }
      
      if (mapIndex !== -1) {
        results.orderDetails.push("✓ map() détecté");
      } else {
        results.issues.push("map() manquant pour convertir la valeur du potentiomètre");
      }
      
      if (delayTimeIndex !== -1) {
        results.orderDetails.push("✓ Variable delayTime utilisée");
      }
      
      // Ordre: analogRead → map → utilisation delayTime
      if (analogReadIndex !== -1 && mapIndex !== -1) {
        if (analogReadIndex < mapIndex) {
          results.hasCorrectOrder = true;
          results.orderDetails.push("✓ Ordre correct: lecture → conversion → utilisation");
        } else {
          results.warnings.push("Placez analogRead() avant map()");
        }
      }
    }
    
    // Exercice 9: 2 boutons PWM - lecture boutons avant ajustement brightness
    else if (exerciseNum === 9) {
      let digitalReadCount = 0;
      let brightnessAdjustIndex = -1;
      let constrainIndex = -1;
      let analogWriteIndex = -1;
      
      meaningfulLines.forEach((line, index) => {
        if (line.includes('digitalRead(')) {
          digitalReadCount++;
        }
        if (line.includes('brightness +=') || line.includes('brightness -=')) {
          brightnessAdjustIndex = index;
        }
        if (line.includes('constrain(')) {
          constrainIndex = index;
        }
        if (line.includes('analogWrite(')) {
          analogWriteIndex = index;
        }
      });
      
      if (digitalReadCount >= 2) {
        results.orderDetails.push(`✓ ${digitalReadCount} lectures de boutons détectées`);
      } else {
        results.issues.push(`Besoin de 2 digitalRead() pour les 2 boutons (trouvé: ${digitalReadCount})`);
      }
      
      if (brightnessAdjustIndex !== -1) {
        results.orderDetails.push("✓ Ajustement de brightness détecté");
      } else {
        results.issues.push("Ajustement de brightness (+= ou -=) manquant");
      }
      
      if (constrainIndex !== -1) {
        results.orderDetails.push("✓ constrain() détecté");
      } else {
        results.issues.push("constrain() manquant pour limiter brightness entre 0-255");
      }
      
      // Ordre: digitalRead → ajustement → constrain → analogWrite
      let correctOrder = true;
      if (constrainIndex !== -1 && brightnessAdjustIndex !== -1 && constrainIndex < brightnessAdjustIndex) {
        results.warnings.push("Placez constrain() APRÈS l'ajustement de brightness");
        correctOrder = false;
      }
      
      results.hasCorrectOrder = digitalReadCount >= 2 && brightnessAdjustIndex !== -1 && constrainIndex !== -1 && correctOrder;
    }
    
    // Exercice 10: Interruption - volatile avant attachInterrupt
    else if (exerciseNum === 10) {
      let volatileIndex = -1;
      let attachInterruptIndex = -1;
      let isrIndex = -1;
      let patternSwitchIndex = -1;
      
      meaningfulLines.forEach((line, index) => {
        if (line.includes('volatile')) {
          volatileIndex = index;
        }
        if (line.includes('attachInterrupt(')) {
          attachInterruptIndex = index;
        }
        if (line.includes('changePatternISR')) {
          isrIndex = index;
        }
        if (line.includes('switch(pattern)')) {
          patternSwitchIndex = index;
        }
      });
      
      if (volatileIndex !== -1) {
        results.orderDetails.push("✓ Variable volatile détectée");
      } else {
        results.issues.push("Variable 'volatile' manquante pour la communication avec l'ISR");
      }
      
      if (attachInterruptIndex !== -1) {
        results.orderDetails.push("✓ attachInterrupt() détecté");
      } else {
        results.issues.push("attachInterrupt() manquant pour configurer l'interruption");
      }
      
      if (isrIndex !== -1) {
        results.orderDetails.push("✓ Fonction ISR (changePatternISR) détectée");
      }
      
      if (patternSwitchIndex !== -1) {
        results.orderDetails.push("✓ switch(pattern) détecté");
      } else {
        results.issues.push("Structure switch(pattern) manquante pour changer les patterns");
      }
      
      // Ordre: volatile variable → ISR → attachInterrupt
      if (volatileIndex !== -1 && attachInterruptIndex !== -1) {
        if (volatileIndex < attachInterruptIndex) {
          results.hasCorrectOrder = true;
          results.orderDetails.push("✓ Ordre correct: volatile avant attachInterrupt");
        } else {
          results.warnings.push("Déclarez la variable volatile avant attachInterrupt()");
        }
      }
    }
    
    // Pour les exercices non spécifiés, l'ordre est moins critique
    else {
      // Vérifications basiques
      let hasSetup = false;
      let hasLoop = false;
      
      meaningfulLines.forEach(line => {
        if (line.includes('void setup()')) hasSetup = true;
        if (line.includes('void loop()')) hasLoop = true;
      });
      
      if (hasSetup && hasLoop) {
        results.hasCorrectOrder = true;
        results.orderDetails.push("✓ Structure Arduino de base correcte");
      } else {
        if (!hasSetup) results.issues.push("Fonction setup() manquante");
        if (!hasLoop) results.issues.push("Fonction loop() manquante");
      }
    }
    
    return results;
  }


  // 2. Vérifier les valeurs exactes requises
function checkExactValues(code, exerciseNum) {
    const issues = [];
    const warnings = [];
    const lines = code.split('\n');
    
    // Exercice 1: delay(1000) exactement
    if (exerciseNum === 1) {
      let delay1000Count = 0;
      let otherDelayCount = 0;
      
      lines.forEach((line, index) => {
        const trimmed = line.trim();
        if (trimmed.includes('delay(')) {
          const delayMatch = trimmed.match(/delay\s*\(\s*(\d+)\s*\)/);
          if (delayMatch) {
            const value = parseInt(delayMatch[1]);
            if (value === 1000) {
              delay1000Count++;
            } else {
              otherDelayCount++;
              issues.push(`Ligne ${index + 1}: delay(${value}) → devrait être delay(1000) pour 1 seconde`);
            }
          }
        }
        
        // Vérifier la broche 13
        if (trimmed.includes('digitalWrite(') && !trimmed.includes('digitalWrite(13,')) {
          const pinMatch = trimmed.match(/digitalWrite\s*\(\s*(\d+)\s*,/);
          if (pinMatch && pinMatch[1] !== '13') {
            warnings.push(`Ligne ${index + 1}: digitalWrite(${pinMatch[1]}, ...) → exercice demande broche 13`);
          }
        }
      });
      
      if (delay1000Count < 2) {
        issues.push(`Besoin de 2× delay(1000), vous avez ${delay1000Count}`);
      }
      if (otherDelayCount > 0) {
        issues.push(`Utilisez delay(1000) pour 1 seconde, pas d'autres valeurs`);
      }
    }
    
    // Exercice 2: delay(200) pour l'effet chassé
    else if (exerciseNum === 2) {
      let delay200Count = 0;
      let otherDelayCount = 0;
      
      lines.forEach((line, index) => {
        const trimmed = line.trim();
        if (trimmed.includes('delay(')) {
          const delayMatch = trimmed.match(/delay\s*\(\s*(\d+)\s*\)/);
          if (delayMatch) {
            const value = parseInt(delayMatch[1]);
            if (value === 200) {
              delay200Count++;
            } else if (value >= 50 && value <= 1000) {
              // Acceptable mais pas idéal
              warnings.push(`Ligne ${index + 1}: delay(${value}) → delay(200) serait meilleur pour l'effet`);
            } else {
              issues.push(`Ligne ${index + 1}: delay(${value}) → délai inapproprié, utilisez ~200ms`);
            }
          }
        }
      });
      
      if (delay200Count === 0 && otherDelayCount === 0) {
        issues.push("Besoin d'un delay() pour contrôler la vitesse de la séquence");
      }
    }
    
    // Exercice 3: delay(30) pour l'effet respiration
    else if (exerciseNum === 3) {
      let hasDelay = false;
      let appropriateDelay = false;
      
      lines.forEach((line, index) => {
        const trimmed = line.trim();
        if (trimmed.includes('delay(')) {
          hasDelay = true;
          const delayMatch = trimmed.match(/delay\s*\(\s*(\d+)\s*\)/);
          if (delayMatch) {
            const value = parseInt(delayMatch[1]);
            if (value >= 10 && value <= 50) {
              appropriateDelay = true;
            } else {
              warnings.push(`Ligne ${index + 1}: delay(${value}) → valeur ${value > 50 ? 'trop grande' : 'trop petite'} pour un effet fluide`);
            }
          }
        }
      });
      
      if (!hasDelay) {
        issues.push("Besoin d'un delay() pour contrôler la vitesse de l'effet PWM");
      }
    }
    
    // Exercice 4: setColor(255,0,0) etc.
    else if (exerciseNum === 4) {
      const requiredColors = [
        { name: "Rouge", values: [255, 0, 0] },
        { name: "Vert", values: [0, 255, 0] },
        { name: "Bleu", values: [0, 0, 255] }
      ];
      
      const codeStr = code.replace(/\s/g, '');
      
      requiredColors.forEach(color => {
        const pattern = `setColor\\(${color.values.join(',')}\\)`;
        if (!new RegExp(pattern).test(codeStr)) {
          issues.push(`Couleur ${color.name} manquante: setColor(${color.values.join(', ')})`);
        }
      });
      
      // Vérifier delay(1000)
      let delay1000Count = 0;
      lines.forEach((line, index) => {
        if (line.includes('delay(1000)')) {
          delay1000Count++;
        } else if (line.includes('delay(')) {
          const delayMatch = line.match(/delay\s*\(\s*(\d+)\s*\)/);
          if (delayMatch && parseInt(delayMatch[1]) !== 1000) {
            warnings.push(`Ligne ${index + 1}: Utilisez delay(1000) pour 1 seconde entre les couleurs`);
          }
        }
      });
      
      if (delay1000Count < 2) {
        issues.push(`Besoin d'au moins 2× delay(1000) entre les changements de couleur`);
      }
    }
    
    // Exercice 5: Temporisations exactes
    else if (exerciseNum === 5) {
      const requiredDelays = [
        { state: "Rouge", duration: 3000 },
        { state: "Rouge+Jaune", duration: 1000 },
        { state: "Vert", duration: 3000 },
        { state: "Jaune", duration: 1000 }
      ];
      
      let totalDelayChecks = 0;
      lines.forEach((line, index) => {
        if (line.includes('>=') && line.includes('previousMillis')) {
          const delayMatch = line.match(/>=(\s*)(\d+)/);
          if (delayMatch) {
            const value = parseInt(delayMatch[2]);
            totalDelayChecks++;
            
            // Vérifier si c'est une valeur attendue
            const expectedValues = [3000, 1000];
            if (!expectedValues.includes(value)) {
              warnings.push(`Ligne ${index + 1}: Temporisation ${value}ms → devrait être 1000ms ou 3000ms`);
            }
          }
        }
      });
      
      if (totalDelayChecks < 4) {
        issues.push(`Besoin de 4 vérifications de temporisation (3000ms et 1000ms)`);
      }
    }
    
    // Exercice 8: map(..., 0, 4095, 50, 1000)
    else if (exerciseNum === 8) {
      let hasMap = false;
      let correctMap = false;
      
      lines.forEach((line, index) => {
        if (line.includes('map(')) {
          hasMap = true;
          if (line.includes('0, 4095, 50, 1000') || line.includes('0,4095,50,1000')) {
            correctMap = true;
          } else {
            issues.push(`Ligne ${index + 1}: map() incorrect → devrait être map(valeur, 0, 4095, 50, 1000)`);
          }
        }
      });
      
      if (!hasMap) {
        issues.push("map() manquant pour convertir la valeur du potentiomètre");
      }
    }
    
    // Exercice 9: constrain(brightness, 0, 255)
    else if (exerciseNum === 9) {
      let hasConstrain = false;
      
      lines.forEach((line, index) => {
        if (line.includes('constrain(')) {
          hasConstrain = true;
          if (!line.includes('0, 255') && !line.includes('0,255')) {
            issues.push(`Ligne ${index + 1}: constrain() incorrect → devrait être constrain(brightness, 0, 255)`);
          }
        }
      });
      
      if (!hasConstrain) {
        issues.push("constrain() manquant pour limiter la luminosité entre 0 et 255");
      }
    }
    
    return { issues, warnings };
  }
  

  // 3. Vérifier la complétude globale
function checkExerciseCompleteness(code, exerciseNum) {
    const exercise = exercises[exerciseNum];
    if (!exercise) return { complete: false, score: 0, details: [] };
    
    const cleanCode = removeCommentsAndWhitespace(code);
    let score = 0;
    let details = [];
    let missing = [];
    
    // Points pour les éléments de base (commun à tous)
    if (/voidsetup\(\)/.test(cleanCode)) score += 10;
    if (/voidloop\(\)/.test(cleanCode)) score += 10;
    
    // Vérifications spécifiques par exercice
    switch(exerciseNum) {
      case 1:
        if (/pinMode\(13,OUTPUT\)/.test(cleanCode)) { score += 20; details.push("✓ pinMode(13, OUTPUT)"); }
        else { missing.push("pinMode(13, OUTPUT)"); }
        
        if (/digitalWrite\(13,HIGH\)/.test(cleanCode)) { score += 20; details.push("✓ digitalWrite(13, HIGH)"); }
        else { missing.push("digitalWrite(13, HIGH) - pour allumer"); }
        
        if (/digitalWrite\(13,LOW\)/.test(cleanCode)) { score += 20; details.push("✓ digitalWrite(13, LOW)"); }
        else { missing.push("digitalWrite(13, LOW) - pour éteindre"); }
        
        const delayMatches = (cleanCode.match(/delay\(1000\)/g) || []);
        if (delayMatches.length >= 2) { score += 30; details.push("✓ 2× delay(1000)"); }
        else { missing.push(`${2 - delayMatches.length}× delay(1000) manquant(s)`); }
        
        // Vérifier l'ordre
        const orderResult = checkInstructionOrder(code, 1);
        if (orderResult.hasCorrectOrder) { score += 20; details.push("✓ Ordre correct: HIGH avant LOW"); }
        else { missing.push("Ordre incorrect: allumer (HIGH) avant éteindre (LOW)"); }
        break;
        
      case 2:
        if (/leds\[\]=\{.*\}/.test(cleanCode)) { score += 20; details.push("✓ Tableau leds[]"); }
        else { missing.push("Tableau leds[] avec les broches"); }
        
        if (/for.*pinMode.*leds\[i\]/.test(cleanCode)) { score += 20; details.push("✓ Configuration LEDs en boucle"); }
        else { missing.push("Boucle for pour configurer les LEDs"); }
        
        if (/for.*digitalWrite.*leds\[i\]/.test(cleanCode)) { score += 20; details.push("✓ Contrôle LEDs en boucle"); }
        else { missing.push("Boucle for pour contrôler les LEDs"); }
        
        if (/delay\(200\)/.test(cleanCode)) { score += 20; details.push("✓ delay(200)"); }
        else { missing.push("delay(200) pour la vitesse"); }
        
        if (/for.*i.*<.*4/.test(cleanCode)) { score += 20; details.push("✓ Boucle for avec 4 itérations"); }
        else { missing.push("Boucle for de 0 à 3"); }
        break;
        
      case 3:
        if (/analogWrite\(/.test(cleanCode)) { score += 25; details.push("✓ analogWrite()"); }
        else { missing.push("analogWrite() pour PWM"); }
        
        if (/brightness.*[+\-]=/.test(cleanCode)) { score += 25; details.push("✓ Modification brightness"); }
        else { missing.push("Modification de la variable brightness"); }
        
        if (/if.*brightness.*[<>]=.*\d+.*\)/.test(cleanCode)) { score += 25; details.push("✓ Vérification limites"); }
        else { missing.push("Vérification des limites (0 et 255)"); }
        
        if (/fadeAmount\s*=\s*-\s*fadeAmount/.test(cleanCode)) { score += 25; details.push("✓ Inversion fadeAmount"); }
        else { missing.push("Inversion de fadeAmount aux limites"); }
        break;
        
      // Continuer pour les autres exercices...
      default:
        // Pour les exercices non spécifiés, vérifications basiques
        if (/pinMode\(/.test(cleanCode)) score += 25;
        if (/digitalWrite\(/.test(cleanCode)) score += 25;
        if (/analogWrite\(/.test(cleanCode)) score += 25;
        if (/delay\(/.test(cleanCode)) score += 25;
    }
    
    // Limiter le score à 100
    score = Math.min(100, score);
    
    return {
      complete: score >= 70,
      score: score,
      details: details,
      missing: missing
    };
  }

    // Check solution
  // REMPLACER la fonction checkSolution() par :
function checkSolution() {
    const exercise = exercises[currentExercise];
    if (!exercise) return;
    
    const code = userCode[currentExercise] || '';
    
    // Analyse complète du code
    const completeness = checkExerciseCompleteness(code, currentExercise);
    const orderCheck = checkInstructionOrder(code, currentExercise);
    const valueCheck = checkExactValues(code, currentExercise);
    
    // Configurer le feedback
    const feedbackArea = document.getElementById('feedback-area');
    const feedbackContent = document.getElementById('feedback-content');
    const feedbackTitle = document.getElementById('feedback-title');
    const feedbackIcon = document.getElementById('feedback-icon');
    
    if (!feedbackArea || !feedbackContent) return;
    
    let feedback = '';
    let isSuccess = completeness.complete;
    let score = completeness.score;
    
    // En-tête avec score
    feedback += `<p><strong>Score: ${score}%</strong></p>`;
    feedback += `<div style="background: #f0f0f0; border-radius: 5px; padding: 10px; margin: 10px 0;">`;
    
    // Éléments corrects
    if (completeness.details.length > 0) {
      feedback += `<p><strong>✅ Correct:</strong></p><ul>`;
      completeness.details.forEach(detail => {
        feedback += `<li>${detail}</li>`;
      });
      feedback += `</ul>`;
    }
    
    // Éléments manquants
    if (completeness.missing.length > 0) {
      feedback += `<p><strong>❌ Manquant:</strong></p><ul>`;
      completeness.missing.forEach(item => {
        feedback += `<li>${item}</li>`;
      });
      feedback += `</ul>`;
    }
    
    feedback += `</div>`;
    
    // Problèmes d'ordre
    if (orderCheck.issues.length > 0) {
      feedback += `<div class="feedback-hint" style="margin-top: 15px;">`;
      feedback += `<h5><i class="fas fa-sort"></i> Problèmes d'ordre:</h5><ul>`;
      orderCheck.issues.forEach(issue => {
        feedback += `<li>${issue}</li>`;
      });
      feedback += `</ul></div>`;
    }
    
    // Valeurs incorrectes
    if (valueCheck.issues.length > 0) {
      feedback += `<div class="feedback-hint" style="margin-top: 15px; background: #ffebee;">`;
      feedback += `<h5><i class="fas fa-exclamation-triangle"></i> Valeurs à corriger:</h5><ul>`;
      valueCheck.issues.forEach(issue => {
        feedback += `<li>${issue}</li>`;
      });
      feedback += `</ul></div>`;
    }
    
    // Suggestions
    if (valueCheck.warnings.length > 0) {
      feedback += `<div class="feedback-hint" style="margin-top: 15px;">`;
      feedback += `<h5><i class="fas fa-lightbulb"></i> Suggestions:</h5><ul>`;
      valueCheck.warnings.forEach(warning => {
        feedback += `<li>${warning}</li>`;
      });
      feedback += `</ul></div>`;
    }
    
    // Conclusion
    if (isSuccess && score >= 80) {
      feedback += `<p class="feedback-success" style="margin-top: 15px; padding: 10px; border-radius: 5px;">
                   <i class="fas fa-check-circle"></i> Félicitations! Votre code est complet et correct.</p>`;
      feedbackTitle.textContent = "Excellent!";
      feedbackIcon.className = "fas fa-trophy";
      feedbackIcon.style.color = "var(--accent-color)";
      
      // Marquer comme complété
      if (!completedExercises.includes(currentExercise)) {
        completedExercises.push(currentExercise);
        localStorage.setItem('completedExercises', JSON.stringify(completedExercises));
        updateProgress();
        showAchievement(`Exercice #${currentExercise} réussi avec ${score}%!`);
      }
    } else if (isSuccess && score >= 70) {
      feedback += `<p class="feedback-success" style="margin-top: 15px; padding: 10px; border-radius: 5px;">
                   <i class="fas fa-check"></i> Code acceptable mais peut être amélioré.</p>`;
      feedbackTitle.textContent = "Bien!";
      feedbackIcon.className = "fas fa-check-circle";
      feedbackIcon.style.color = "var(--success-color)";
    } else {
      feedback += `<p class="feedback-error" style="margin-top: 15px; padding: 10px; border-radius: 5px;">
                   <i class="fas fa-exclamation-triangle"></i> Code incomplet. Continuez à travailler!</p>`;
      feedbackTitle.textContent = "À améliorer";
      feedbackIcon.className = "fas fa-exclamation-triangle";
      feedbackIcon.style.color = "var(--warning-color)";
    }
    
    // Ajouter les indices si nécessaire
    if (score < 80 && exercise.hints) {
      feedback += `<div class="feedback-hint" style="margin-top: 15px;">`;
      feedback += `<h5><i class="fas fa-lightbulb"></i> Rappel des objectifs:</h5><ul>`;
      exercise.objectives.forEach(obj => {
        feedback += `<li>${obj}</li>`;
      });
      feedback += `</ul></div>`;
    }
    
    feedbackContent.innerHTML = feedback;
    feedbackArea.classList.add('show');
  }
    // Show hint
    function showHint() {
      const exercise = exercises[currentExercise];
      if (!exercise) return;
      
      const feedbackArea = document.getElementById('feedback-area');
      const feedbackContent = document.getElementById('feedback-content');
      const feedbackTitle = document.getElementById('feedback-title');
      const feedbackIcon = document.getElementById('feedback-icon');
      
      if (!feedbackArea || !feedbackContent) return;
      
      feedbackTitle.textContent = "Indices";
      feedbackIcon.className = "fas fa-lightbulb";
      feedbackIcon.style.color = "var(--warning-color)";
      
      let feedback = `<div class="feedback-hint">
        <h5><i class="fas fa-lightbulb"></i> Conseils pour cet exercice:</h5>
        <ul>`;
      
      exercise.hints.forEach(hint => {
        feedback += `<li>${hint}</li>`;
      });
      
      feedback += `</ul></div>`;
      
      feedbackContent.innerHTML = feedback;
      feedbackArea.classList.add('show');
    }

    // Show solution
    function showSolution() {
      const exercise = exercises[currentExercise];
      if (!exercise) return;
      
      loadCodeTemplate(exercise.solution);
      
      const feedbackArea = document.getElementById('feedback-area');
      const feedbackContent = document.getElementById('feedback-content');
      const feedbackTitle = document.getElementById('feedback-title');
      const feedbackIcon = document.getElementById('feedback-icon');
      
      if (!feedbackArea || !feedbackContent) return;
      
      feedbackTitle.textContent = "Solution";
      feedbackIcon.className = "fas fa-eye";
      feedbackIcon.style.color = "var(--primary-color)";
      
      const feedback = `<p>Voici la solution complète. Essayez de comprendre chaque ligne!</p>
                       <p><small>Après avoir étudié la solution, essayez de la réécrire vous-même.</small></p>`;
      
      feedbackContent.innerHTML = feedback;
      feedbackArea.classList.add('show');
    }

    // Close workspace
    function closeWorkspace() {
      const workspace = document.getElementById('exercise-workspace');
      if (workspace) {
        workspace.style.display = 'none';
      }
      if (simulationInterval) {
        clearInterval(simulationInterval);
        simulationInterval = null;
      }
    }

    // Update progress
    function updateProgress() {
      const totalExercises = Object.keys(exercises).length;
      const completed = completedExercises.length;
      const progress = (completed / totalExercises) * 100;
      
      const progressText = document.getElementById('progress-text');
      const progressBar = document.getElementById('progress-bar');
      
      if (progressText) {
        progressText.textContent = `${completed}/${totalExercises} exercices complétés`;
      }
      if (progressBar) {
        progressBar.style.width = `${progress}%`;
      }
      
      // Update status indicators
      for (let i = 1; i <= totalExercises; i++) {
        const statusElem = document.getElementById(`status-${i}`);
        if (statusElem) {
          if (completedExercises.includes(i)) {
            statusElem.innerHTML = '<i class="fas fa-check-circle" style="color: var(--success-color)"></i> Complété';
            statusElem.style.color = "var(--success-color)";
          } else {
            statusElem.innerHTML = '<i class="far fa-circle"></i> Non tenté';
            statusElem.style.color = "#6c757d";
          }
        }
      }
    }

    // Load exercise status
    function loadExerciseStatus() {
      updateProgress();
    }

    // Configure LEDs dialog
    function configureLEDs() {
      const exercise = exercises[currentExercise];
      if (!exercise) return;
      
      const feedbackArea = document.getElementById('feedback-area');
      const feedbackContent = document.getElementById('feedback-content');
      const feedbackTitle = document.getElementById('feedback-title');
      const feedbackIcon = document.getElementById('feedback-icon');
      
      if (!feedbackArea || !feedbackContent) return;
      
      let configHTML = '<h4>Configuration des LEDs</h4>';
      configHTML += '<p>Associez chaque LED à une broche GPIO:</p>';
      
      exercise.leds.forEach(led => {
        configHTML += `
          <div style="margin: 10px 0; display: flex; align-items: center; gap: 10px;">
            <div class="led led-${led.color}" style="width: 30px; height: 30px;"></div>
            <span>LED ${led.id}:</span>
            <select id="led-pin-${led.id}" style="padding: 5px; border-radius: 4px;">
              ${exercise.pins.map(pin => `<option value="${pin}" ${pin === led.pin ? 'selected' : ''}>GPIO${pin}</option>`).join('')}
            </select>
          </div>
        `;
      });
      
      configHTML += '<button onclick="saveLEDsConfiguration()" style="margin-top: 15px; padding: 8px 16px; background-color: var(--primary-color); color: white; border: none; border-radius: 4px; cursor: pointer;">Sauvegarder</button>';
      
      feedbackTitle.textContent = "Configuration LEDs";
      feedbackIcon.className = "fas fa-cog";
      feedbackIcon.style.color = "var(--primary-color)";
      
      feedbackContent.innerHTML = configHTML;
      feedbackArea.classList.add('show');
    }

    // Save LEDs configuration
    function saveLEDsConfiguration() {
      const exercise = exercises[currentExercise];
      if (!exercise) return;
      
      exercise.leds.forEach(led => {
        const select = document.getElementById(`led-pin-${led.id}`);
        if (select) {
          led.pin = parseInt(select.value);
        }
      });
      
      // Reconfigure LEDs
      configureExerciseLEDs(exercise.leds);
      
      const feedbackArea = document.getElementById('feedback-area');
      if (feedbackArea) {
        feedbackArea.classList.remove('show');
      }
      addSerialLine('Configuration LEDs mise à jour');
    }

    // Clear serial monitor
    function clearSerialMonitor() {
      const monitor = document.getElementById('serial-monitor');
      if (monitor) {
        monitor.innerHTML = '<div class="serial-line">Moniteur série initialisé (115200 baud)</div>';
      }
    }

    // Add line to serial monitor
    function addSerialLine(text) {
      const monitor = document.getElementById('serial-monitor');
      if (!monitor) return;
      
      const line = document.createElement('div');
      line.className = 'serial-line';
      line.textContent = `> ${text}`;
      monitor.appendChild(line);
      monitor.scrollTop = monitor.scrollHeight;
    }

    // Show achievement
    function showAchievement(message) {
      const banner = document.getElementById('achievement-banner');
      const achievementMessage = document.getElementById('achievement-message');
      
      if (banner && achievementMessage) {
        achievementMessage.textContent = message;
        banner.style.display = 'block';
        
        // Auto-hide after 5 seconds
        setTimeout(hideAchievement, 5000);
      }
    }

    // Hide achievement
    function hideAchievement() {
      const banner = document.getElementById('achievement-banner');
      if (banner) {
        banner.style.display = 'none';
      }
    }

    // Initialize pins configuration
    function initPinsConfiguration() {
      for (let i = 0; i <= 39; i++) {
        pinsConfiguration[i] = {
          mode: 'input',
          state: 'low',
          pwm: [2, 4, 12, 13, 14, 15, 18, 19, 21, 22, 23, 25, 26, 27, 32, 33].includes(i)
        };
      }
    }
    const header = document.querySelector(".hero");

const images = [
    "./image/closeup-electronic-circuit-board-with-cpu-microchip-electronic-components-background.jpg",
    "./image/top-view-wires-tech-background.jpg",
    "./image/using-pliers-circuit-board.jpg",
    "./image/father-son-making-robot.jpg",
    "./image/robot-style-car-with-joystick.jpg"
];

let index = 0;

function changeHeaderBackground() {
    header.style.backgroundImage = `url('${images[index]}')`;
    index = (index + 1) % images.length;
}

// image au chargement
changeHeaderBackground();

// changer toutes les 3 secondes
setInterval(changeHeaderBackground, 3000);
 
  </script>
</body>
</html>