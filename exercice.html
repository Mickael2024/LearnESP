<!DOCTYPE html>
<html lang="fr">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ArduinoLearn - Quiz Programmation</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    :root {
      --primary-color: #00979c;
      --secondary-color: #00696b;
      --accent-color: #ff9800;
      --light-color: #f8f9fa;
      --dark-color: #333;
      --gray-color: #6c757d;
      --code-bg: #f4f4f4;
      --success-color: #28a745;
      --warning-color: #ffc107;
      --danger-color: #dc3545;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    body {
      background-color: #f5f5f5;
      color: var(--dark-color);
      line-height: 1.6;
    }

    .container {
      width: 100%;
      margin: 0 auto;
      padding: 0 20px;
    }

    /* Header */
    header {
      background-color: var(--primary-color);
      color: white;
      padding: 1rem 0;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      position: sticky;
      top: 0;
      z-index: 100;
    }

    .header-content {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .logo {
      font-size: 1.8rem;
      font-weight: 700;
      display: flex;
      align-items: center;
    }

    .logo i {
      margin-right: 10px;
      color: var(--accent-color);
    }

    .logo span {
      color: var(--accent-color);
    }

    nav ul {
      display: flex;
      list-style: none;
    }

    nav ul li {
      margin-left: 1.5rem;
    }

    nav ul li a {
      color: white;
      text-decoration: none;
      font-weight: 500;
      transition: color 0.3s;
      padding: 5px 10px;
      border-radius: 4px;
    }

    nav ul li a:hover,
    nav ul li a.active {
      color: var(--accent-color);
      background-color: rgba(255, 255, 255, 0.1);
    }

    /* =========================================== */
    /* BOUTON HAMBURGER POUR MOBILE */
    /* =========================================== */
    .hamburger-btn {
      display: none;
      background: none;
      border: none;
      color: white;
      font-size: 1.5rem;
      cursor: pointer;
      padding: 0.5rem;
      z-index: 1001;
    }

    .hamburger-btn:focus {
      outline: 2px solid var(--accent-color);
      border-radius: 4px;
    }

    /* Menu mobile */
    .nav-menu {
      display: flex;
      list-style: none;
      transition: all 0.3s ease;
    }

    /* Overlay pour mobile */
    .mobile-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0, 0, 0, 0.7);
      opacity: 0;
      transition: opacity 0.3s ease;
      z-index: 999;
    }

    .mobile-overlay.active {
      display: block;
      opacity: 1;
    }

    /* =========================================== */
    /* RESPONSIVE HEADER */
    /* =========================================== */
    @media (max-width: 768px) {
      .hamburger-btn {
        display: block;
      }

      nav {
        position: fixed;
        top: 70px;
        left: -100%;
        width: 280px;
        height: calc(100vh - 70px);
        background-color: var(--primary-color);
        box-shadow: 4px 0 15px rgba(0, 0, 0, 0.2);
        z-index: 1000;
        transition: left 0.3s ease;
        overflow-y: auto;
      }

      nav.active {
        left: 0;
      }

      nav ul {
        margin-top: 1rem;
        justify-content: flex-start;
        flex-wrap: wrap;
        flex-direction: column;
        align-content: flex-start;
        line-height: 4;
        font-size: unset;
      }

      .nav-menu {
        flex-direction: column;
        padding: 1rem 0;
        width: 100%;
      }

      .nav-menu li {
        margin: 0;
        width: 100%;
      }

      .nav-menu li a {
        display: flex;
        align-items: center;
        padding: 1rem 1.5rem;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        width: 100%;
        font-size: 1rem;
      }

      .nav-menu li a i {
        width: 24px;
        margin-right: 12px;
        font-size: 1.1rem;
      }

      .nav-menu li a:hover,
      .nav-menu li a.active {
        background-color: rgba(255, 255, 255, 0.15);
        padding-left: 2rem;
      }

      .header-content {
        justify-content: space-between;
      }
    }

    @media (max-width: 480px) {
      nav {
        width: 50%;
        left: -100%;
      }

      .nav-menu li a {
        padding: 1.2rem 1.5rem;
      }
    }

    .hamburger-btn .fa-times {
      display: none;
    }

    .hamburger-btn.active .fa-bars {
      display: none;
    }

    .hamburger-btn.active .fa-times {
      display: inline-block;
    }

    /* Hero Section */
    .hero {
      background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
      color: white;
      padding: 3rem 0;
      text-align: center;
      margin-bottom: 2rem;
    }

    .hero h1 {
      font-size: 2.5rem;
      margin-bottom: 1rem;
    }

    .hero p {
      font-size: 1.1rem;
      max-width: 800px;
      margin: 0 auto 1.5rem;
      opacity: 0.9;
    }

    /* Main Content */
    .main-content {
      display: flex;
      flex-direction: column;
      gap: 2rem;
      margin-bottom: 3rem;
    }

    /* Instructions */
    .instructions {
      background-color: #e9f7f7;
      padding: 1.5rem;
      border-radius: 10px;
      margin-bottom: 2rem;
      border-left: 5px solid var(--primary-color);
    }

    .instructions h3 {
      color: var(--primary-color);
      margin-bottom: 1rem;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .instructions ul {
      padding-left: 1.5rem;
      margin-bottom: 1rem;
    }

    .instructions li {
      margin-bottom: 0.5rem;
    }

    /* Categories */
    .category-tabs {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 2rem;
      justify-content: center;
    }

    .category-btn {
      padding: 0.8rem 1.5rem;
      background-color: white;
      border: 2px solid var(--primary-color);
      border-radius: 30px;
      color: var(--primary-color);
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
    }

    .category-btn:hover,
    .category-btn.active {
      background-color: var(--primary-color);
      color: white;
    }

    /* Quiz Grid */
    .quiz-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
      gap: 2rem;
      margin: 2rem 0;
    }

    .quiz-card {
      background-color: white;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 6px 15px rgba(0, 0, 0, 0.1);
      transition: transform 0.3s, box-shadow 0.3s;
      border: 2px solid transparent;
      cursor: pointer;
      opacity: 0.9;
    }

    .quiz-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 12px 25px rgba(0, 0, 0, 0.15);
      opacity: 1;
    }

    .quiz-header {
      background-color: var(--primary-color);
      color: white;
      padding: 1.2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .quiz-header h3 {
      margin: 0;
      font-size: 1.3rem;
    }

    .quiz-difficulty {
      padding: 0.3rem 1rem;
      border-radius: 20px;
      font-size: 0.85rem;
      font-weight: 600;
      text-transform: uppercase;
    }

    .difficulty-beginner {
      background-color: var(--success-color);
    }

    .difficulty-intermediate {
      background-color: var(--warning-color);
      color: var(--dark-color);
    }

    .difficulty-advanced {
      background-color: var(--danger-color);
    }

    .quiz-body {
      padding: 1.5rem;
    }

    .quiz-question {
      margin-bottom: 1rem;
      color: var(--dark-color);
      min-height: 80px;
    }

    .quiz-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin: 1rem 0;
    }

    .tag {
      background-color: #e9ecef;
      padding: 0.3rem 0.8rem;
      border-radius: 20px;
      font-size: 0.8rem;
      color: var(--dark-color);
    }

    .quiz-status {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 1rem;
      padding-top: 1rem;
      border-top: 1px solid #eee;
    }

    /* Quiz Workspace */
    .quiz-workspace {
      background-color: white;
      border-radius: 12px;
      padding: 2rem;
      box-shadow: 0 6px 15px rgba(0, 0, 0, 0.1);
      margin-bottom: 2rem;
      display: none;
    }

    .workspace-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1.5rem;
      padding-bottom: 1rem;
      border-bottom: 2px solid #eee;
      flex-wrap: wrap;
      gap: 1rem;
    }

    .workspace-title {
      color: var(--primary-color);
      font-size: 1.5rem;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .question-box {
      background-color: #f8f9fa;
      padding: 1.5rem;
      border-radius: 10px;
      margin-bottom: 2rem;
      border-left: 4px solid var(--primary-color);
    }

    .question-box h3 {
      color: var(--primary-color);
      margin-bottom: 1rem;
    }

    .question-text {
      font-size: 1.2rem;
      margin-bottom: 1rem;
      font-weight: 500;
    }

    .objective-list {
      padding-left: 1.5rem;
      margin-top: 0.5rem;
    }

    .objective-list li {
      margin-bottom: 0.3rem;
    }

    /* Code Editor */
    .code-editor-container {
      background-color: #2d2d2d;
      border-radius: 10px;
      overflow: hidden;
      margin-bottom: 2rem;
    }

    .code-header {
      background-color: #1e1e1e;
      padding: 0.8rem 1.2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      color: #aaa;
    }

    .code-filename {
      font-family: monospace;
    }

    .editor-dots {
      display: flex;
      gap: 6px;
    }

    .editor-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
    }

    .editor-dot.red { background-color: #ff5f56; }
    .editor-dot.yellow { background-color: #ffbd2e; }
    .editor-dot.green { background-color: #27ca3f; }

    .code-area {
      padding: 1.5rem;
      background-color: #1e1e1e;
    }

    .code-input {
      width: 100%;
      min-height: 250px;
      background-color: #1e1e1e;
      color: #d4d4d4;
      border: none;
      font-family: 'Courier New', monospace;
      font-size: 0.95rem;
      line-height: 1.5;
      padding: 0;
      resize: vertical;
      outline: none;
    }

    .code-input:focus {
      border-left: 3px solid var(--primary-color);
      padding-left: 10px;
    }

    /* Multiple Choice */
    .options-container {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      margin: 2rem 0;
    }

    .option-item {
      display: flex;
      align-items: center;
      padding: 1rem;
      background-color: #f8f9fa;
      border: 2px solid #dee2e6;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s;
    }

    .option-item:hover {
      background-color: #e9ecef;
    }

    .option-item.selected {
      border-color: var(--primary-color);
      background-color: #e3f2fd;
    }

    .option-item input[type="radio"] {
      margin-right: 1rem;
      width: 18px;
      height: 18px;
      cursor: pointer;
    }

    .option-text {
      font-size: 1rem;
      flex: 1;
    }

    /* Controls */
    .workspace-controls {
      display: flex;
      gap: 1rem;
      margin-top: 2rem;
      flex-wrap: wrap;
      justify-content: center;
    }

    .control-btn {
      padding: 0.7rem 1.5rem;
      background-color: var(--primary-color);
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.3s;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.95rem;
    }

    .control-btn:hover {
      background-color: var(--secondary-color);
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }

    .control-btn.validate {
      background-color: var(--success-color);
    }

    .control-btn.validate:hover {
      background-color: #218838;
    }

    .control-btn.reset {
      background-color: var(--gray-color);
    }

    .control-btn.hint {
      background-color: var(--warning-color);
      color: var(--dark-color);
    }

    /* Feedback Area */
    .feedback-area {
      margin-top: 2rem;
      padding: 1.5rem;
      border-radius: 10px;
      background-color: #f8f9fa;
      border: 1px solid #ddd;
      display: none;
    }

    .feedback-area.show {
      display: block;
      animation: fadeIn 0.5s;
    }

    .feedback-header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 1rem;
      padding-bottom: 0.8rem;
      border-bottom: 2px solid #eee;
    }

    .feedback-title {
      font-size: 1.2rem;
      color: var(--primary-color);
    }

    .feedback-content {
      line-height: 1.6;
    }

    .feedback-success {
      color: var(--success-color);
      font-weight: bold;
    }

    .feedback-error {
      color: var(--danger-color);
      font-weight: bold;
    }

    .feedback-hint {
      background-color: #fff3cd;
      border-left: 4px solid var(--warning-color);
      padding: 1rem;
      margin: 1rem 0;
      border-radius: 4px;
    }

    .code-block {
      background-color: #2d2d2d;
      color: #d4d4d4;
      padding: 1rem;
      border-radius: 6px;
      font-family: 'Courier New', monospace;
      margin: 1rem 0;
      overflow-x: auto;
    }

    /* Progress */
    .progress-container {
      margin: 2rem 0;
      background-color: #e9ecef;
      border-radius: 10px;
      overflow: hidden;
      height: 12px;
    }

    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
      width: 0%;
      transition: width 0.5s ease;
    }

    /* Achievement Banner */
    #achievement-banner {
      position: fixed;
      top: 100px;
      right: 20px;
      background: linear-gradient(135deg, #ff9800, #ff5722);
      color: white;
      padding: 1.5rem;
      border-radius: 10px;
      box-shadow: 0 5px 20px rgba(0,0,0,0.3);
      z-index: 1000;
      max-width: 300px;
      display: none;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @media (max-width: 768px) {
      .quiz-grid {
        grid-template-columns: 1fr;
      }
      
      .workspace-header {
        flex-direction: column;
        align-items: flex-start;
      }
    }
  </style>
</head>

<body>
  <!-- Header identique à l'original -->
  <header>
    <div class="container header-content">
      <div class="logo">
        <button class="hamburger-btn" aria-label="Menu">
          <i class="fas fa-bars"></i>
        </button>
        <i class="fas fa-microchip"></i>
        <div><span>Arduino</span>/ESP</div>
      </div>
      <nav>
        <ul class="nav-menu">
          <li><a href="index.html"><i class="fas fa-home"></i> Accueil</a></li>
          <li><a href="./exemple.html"><i class="fas fa-code"></i> Exemples</a></li>
          <li><a href="./reference.html"><i class="fas fa-book"></i> Référence</a></li>
          <li><a href="exercice.html" class="active"><i class="fas fa-pencil-alt"></i> Quiz</a></li>
          <li><a href="./ide.html"><i class="fas fa-comments"></i> Zone d'Échange</a></li>
        </ul>
      </nav>
    </div>
  </header>

  <!-- Hero Section -->
  <section class="hero">
    <div class="container">
      <h1>Quiz Programmation Arduino/ESP</h1>
      <p>Testez vos connaissances avec 30+ exercices pratiques. Écrivez du code et obtenez une correction instantanée !</p>
      <div style="display: flex; gap: 15px; justify-content: center; margin-top: 1.5rem; flex-wrap: wrap;">
        <div style="background-color: rgba(255,255,255,0.2); padding: 0.5rem 1rem; border-radius: 20px;">
          <i class="fas fa-check-circle" style="margin-right: 8px;"></i>Correction automatique
        </div>
        <div style="background-color: rgba(255,255,255,0.2); padding: 0.5rem 1rem; border-radius: 20px;">
          <i class="fas fa-bolt" style="margin-right: 8px;"></i>Validation en temps réel
        </div>
        <div style="background-color: rgba(255,255,255,0.2); padding: 0.5rem 1rem; border-radius: 20px;">
          <i class="fas fa-lightbulb" style="margin-right: 8px;"></i>Indices disponibles
        </div>
      </div>
    </div>
  </section>

  <div class="container main-content">
    <!-- Instructions -->
    <div class="instructions fade-in">
      <h3><i class="fas fa-info-circle"></i> Comment utiliser les quiz</h3>
      <ul>
        <li>Sélectionnez un quiz dans la liste ci-dessous</li>
        <li>Lisez attentivement la question et les objectifs</li>
        <li>Écrivez votre code dans l'éditeur pour résoudre l'exercice</li>
        <li>Cliquez sur "Valider ma réponse" pour obtenir une correction détaillée</li>
        <li>Utilisez "Indice" si vous avez besoin d'aide</li>
        <li>Votre progression est sauvegardée automatiquement</li>
      </ul>
      <p style="font-weight: bold; color: var(--primary-color);">
        <i class="fas fa-trophy"></i> Votre progression: <span id="progress-text">0/30 quiz complétés</span>
      </p>
      <div class="progress-container">
        <div class="progress-bar" id="progress-bar"></div>
      </div>
    </div>

    <!-- Catégories de quiz -->
    <div class="category-tabs">
      <button class="category-btn active" onclick="filterQuizzes('all')">Tous</button>
      <button class="category-btn" onclick="filterQuizzes('beginner')">Débutant</button>
      <button class="category-btn" onclick="filterQuizzes('intermediate')">Intermédiaire</button>
      <button class="category-btn" onclick="filterQuizzes('advanced')">Avancé</button>
      <button class="category-btn" onclick="filterQuizzes('variables')">Variables</button>
      <button class="category-btn" onclick="filterQuizzes('led')">LED</button>
      <button class="category-btn" onclick="filterQuizzes('buttons')">Boutons</button>
    </div>
<!-- SECTION QUIZ À CHOIX MULTIPLES INDIVIDUELS -->
<div class="quiz-multiple-section" style="margin-top: 3rem; padding-top: 2rem; border-top: 3px dashed var(--primary-color);">
  <h2 style="text-align: center; color: var(--primary-color); margin-bottom: 2rem;">
    <i class="fas fa-check-square"></i> Quiz à choix multiples
  </h2>
  <p style="text-align: center; margin-bottom: 2rem;">Chaque question a son propre bouton de validation</p>
  
  <div id="multiple-choice-quiz-container"></div>
  
  <!-- Résumé global -->
  <div style="margin-top: 3rem; padding: 2rem; background: linear-gradient(135deg, var(--primary-color), var(--secondary-color)); color: white; border-radius: 10px; text-align: center;">
    <h3 style="margin-bottom: 1rem;">Résumé de votre progression</h3>
    <div style="font-size: 2rem; font-weight: bold;" id="global-score">0/0 questions réussies</div>
    <div class="progress-container" style="margin: 1rem 0; background-color: rgba(255,255,255,0.3);">
      <div class="progress-bar" id="global-progress-bar" style="background-color: var(--accent-color); width: 0%;"></div>
    </div>
    <button class="control-btn" onclick="resetAllQuestions()" style="background-color: white; color: var(--primary-color); margin-top: 1rem;">
      <i class="fas fa-redo"></i> Réinitialiser toutes les questions
    </button>
  </div>
</div>
    <!-- Quiz Grid -->
    <div class="quiz-grid" id="quiz-grid"></div>

    <!-- Quiz Workspace -->
    <div class="quiz-workspace" id="quiz-workspace">
      <div class="workspace-header">
        <div class="workspace-title">
          <i class="fas fa-code"></i>
          <span id="workspace-title">Quiz #1: Allumer une LED</span>
        </div>
        <div style="display: flex; gap: 10px;">
          <button class="control-btn hint" onclick="showHint()">
            <i class="fas fa-lightbulb"></i> Indice
          </button>
          <button class="control-btn" onclick="closeWorkspace()">
            <i class="fas fa-times"></i> Fermer
          </button>
        </div>
      </div>

      <div class="question-box" id="question-box">
        <h3><i class="fas fa-question-circle"></i> Question</h3>
        <div class="question-text" id="question-text"></div>
        <h4 style="margin-top: 1rem; color: var(--primary-color);">Objectifs :</h4>
        <ul class="objective-list" id="objective-list"></ul>
      </div>

      <!-- Zone de code -->
      <div class="code-editor-container">
        <div class="code-header">
          <div class="editor-dots">
            <div class="editor-dot red"></div>
            <div class="editor-dot yellow"></div>
            <div class="editor-dot green"></div>
          </div>
          <div class="code-filename" id="code-filename">exercice.ino</div>
        </div>
        <div class="code-area">
          <textarea class="code-input" id="code-input" placeholder="Écrivez votre code Arduino ici..."></textarea>
        </div>
      </div>

      <!-- Options (pour les QCM) -->
      <div class="options-container" id="options-container" style="display: none;"></div>

      <!-- Controls -->
      <div class="workspace-controls">
        <button class="control-btn validate" onclick="validateQuiz()">
          <i class="fas fa-check-double"></i> Valider ma réponse
        </button>
        <button class="control-btn reset" onclick="resetQuiz()">
          <i class="fas fa-redo"></i> Réinitialiser
        </button>
      </div>

      <!-- Feedback Area -->
      <div class="feedback-area" id="feedback-area">
        <div class="feedback-header">
          <i class="fas fa-comment-dots" id="feedback-icon"></i>
          <h3 class="feedback-title" id="feedback-title">Feedback</h3>
        </div>
        <div class="feedback-content" id="feedback-content"></div>
      </div>
    </div>

    <!-- Achievement Banner -->
    <div id="achievement-banner">
      <div style="display: flex; align-items: center; gap: 15px;">
        <i class="fas fa-trophy" style="font-size: 2rem;"></i>
        <div>
          <h4 style="margin: 0; font-size: 1.2rem;">Quiz réussi !</h4>
          <p style="margin: 5px 0 0 0; font-size: 0.9rem;" id="achievement-message"></p>
        </div>
      </div>
      <button onclick="hideAchievement()" style="position: absolute; top: 5px; right: 10px; 
              background: none; border: none; color: white; cursor: pointer; font-size: 1.2rem;">
        <i class="fas fa-times"></i>
      </button>
    </div>
  </div>

  <script>
    // ==================== CONFIGURATION ====================
    let currentQuiz = null;
    let completedQuizzes = JSON.parse(localStorage.getItem('completedQuizzes') || '[]');
    
    // ==================== BASE DE DONNÉES DES QUIZ ====================
    const quizzes = [
      // === NIVEAU DÉBUTANT - VARIABLES ET BASES ===
      {
        id: 1,
        title: "Déclarer une variable",
        difficulty: "Débutant",
        category: "variables",
        question: "Comment déclare-t-on une variable entière (integer) nommée 'compteur' initialisée à 0 en Arduino ?",
        objectives: [
          "Déclarer une variable de type int",
          "Initialiser la variable à 0",
          "Syntaxe correcte Arduino/C++"
        ],
        type: "code",
        template: "// Déclarez ici la variable 'compteur' de type int initialisée à 0\n\nvoid setup() {\n  Serial.begin(9600);\n  Serial.println(compteur);\n}\n\nvoid loop() {}",
        solution: "int compteur = 0;",
        hints: [
          "Le type pour un nombre entier est 'int'",
          "La syntaxe est : type nom = valeur;",
          "Exemple : int maVariable = 5;"
        ],
        validate: function(code) {
          const cleanCode = code.replace(/\s/g, '');
          const hasInt = cleanCode.includes('int');
          const hasCompteur = cleanCode.includes('compteur');
          const hasEquals = cleanCode.includes('=');
          const hasZero = cleanCode.includes('0');
          const hasSemicolon = cleanCode.includes(';');
          
          if (hasInt && hasCompteur && hasEquals && hasZero && hasSemicolon) {
            return { success: true, score: 100, message: "✅ Parfait ! Variable déclarée correctement." };
          } else {
            let missing = [];
            if (!hasInt) missing.push("type 'int'");
            if (!hasCompteur) missing.push("nom 'compteur'");
            if (!hasEquals) missing.push("signe =");
            if (!hasZero) missing.push("valeur 0");
            if (!hasSemicolon) missing.push("point-virgule ;");
            return { success: false, score: 0, message: "❌ Il manque : " + missing.join(", ") };
          }
        }
      },
      {
        id: 2,
        title: "Constante en Arduino",
        difficulty: "Débutant",
        category: "variables",
        question: "Déclarez une constante nommée 'LED_PIN' avec la valeur 13. Une constante ne peut pas être modifiée après sa déclaration.",
        objectives: [
          "Utiliser le mot-clé 'const'",
          "Déclarer une constante pour une broche LED",
          "Respecter les conventions de nommage"
        ],
        type: "code",
        template: "// Déclarez ici la constante LED_PIN = 13\n\nvoid setup() {\n  pinMode(LED_PIN, OUTPUT);\n}\n\nvoid loop() {}",
        solution: "const int LED_PIN = 13;",
        hints: [
          "Utilisez 'const' devant le type",
          "Le type est 'int' pour un nombre",
          "Les constantes s'écrivent souvent en MAJUSCULES"
        ],
        validate: function(code) {
          const cleanCode = code.replace(/\s/g, '');
          const hasConst = cleanCode.includes('const');
          const hasInt = cleanCode.includes('int');
          const hasLedPin = cleanCode.includes('LED_PIN');
          const hasEquals = cleanCode.includes('=');
          const has13 = cleanCode.includes('13');
          
          if (hasConst && hasInt && hasLedPin && hasEquals && has13) {
            return { success: true, score: 100, message: "✅ Parfait ! Constante déclarée correctement." };
          }
          return { success: false, score: 0, message: "❌ Utilisez 'const int LED_PIN = 13;'" };
        }
      },
      {
        id: 3,
        title: "Types de données",
        difficulty: "Débutant",
        category: "variables",
        question: "Quel type de données utiliseriez-vous pour stocker un nombre décimal (ex: 3.14) ?",
        objectives: [
          "Connaître les types de données en Arduino",
          "Choisir le bon type pour un nombre à virgule"
        ],
        type: "qcm",
        options: [
          "int",
          "float",
          "byte",
          "boolean"
        ],
        correct: 1, // index 1 = float
        hints: [
          "int est pour les nombres entiers",
          "float est pour les nombres à virgule flottante",
          "byte est pour les petits entiers (0-255)",
          "boolean est pour vrai/faux"
        ],
        validate: function(selected) {
          return selected === 1;
        }
      },
      {
        id: 4,
        title: "Opération mathématique",
        difficulty: "Débutant",
        category: "variables",
        question: "Écrivez le code pour additionner deux variables 'a' et 'b' et stocker le résultat dans une variable 'somme'.",
        objectives: [
          "Déclarer des variables",
          "Faire une addition",
          "Afficher le résultat"
        ],
        type: "code",
        template: "int a = 5;\nint b = 3;\nint somme;\n\nvoid setup() {\n  Serial.begin(9600);\n  // Calculez a + b et stockez dans somme\n  // Puis affichez somme avec Serial.println()\n}\n\nvoid loop() {}",
        solution: "int a = 5;\nint b = 3;\nint somme;\n\nvoid setup() {\n  Serial.begin(9600);\n  somme = a + b;\n  Serial.println(somme);\n}\n\nvoid loop() {}",
        hints: [
          "Utilisez l'opérateur '+' pour additionner",
          "Stockez le résultat avec 'somme = a + b;'",
          "Affichez avec Serial.println(somme);"
        ],
        validate: function(code) {
          const hasAddition = code.includes('somme = a + b') || code.includes('somme=a+b');
          const hasPrint = code.includes('Serial.println(somme)') || code.includes('Serial.println(somme);');
          
          if (hasAddition && hasPrint) {
            return { success: true, score: 100, message: "✅ Excellent ! Addition et affichage corrects." };
          } else if (hasAddition) {
            return { success: false, score: 50, message: "⚠️ Addition correcte, mais n'oubliez pas d'afficher le résultat avec Serial.println(somme);" };
          } else {
            return { success: false, score: 0, message: "❌ Vous devez calculer somme = a + b" };
          }
        }
      },

      // === NIVEAU DÉBUTANT - LED ===
      {
        id: 5,
        title: "Allumer une LED",
        difficulty: "Débutant",
        category: "led",
        question: "Écrivez le code pour allumer une LED connectée à la broche 13.",
        objectives: [
          "Configurer une broche en sortie (OUTPUT)",
          "Mettre la broche à l'état HIGH"
        ],
        type: "code",
        template: "void setup() {\n  // À compléter\n}\n\nvoid loop() {\n  // À compléter\n}",
        solution: "void setup() {\n  pinMode(13, OUTPUT);\n}\n\nvoid loop() {\n  digitalWrite(13, HIGH);\n}",
        hints: [
          "Utilisez pinMode(13, OUTPUT) dans setup()",
          "Utilisez digitalWrite(13, HIGH) dans loop()",
          "HIGH = allumé, LOW = éteint"
        ],
        validate: function(code) {
          const hasPinMode = code.includes('pinMode(13, OUTPUT)') || code.includes('pinMode(13,OUTPUT)');
          const hasDigitalWrite = code.includes('digitalWrite(13, HIGH)') || code.includes('digitalWrite(13,HIGH)');
          
          if (hasPinMode && hasDigitalWrite) {
            return { success: true, score: 100, message: "✅ Parfait ! LED allumée correctement." };
          } else if (hasPinMode) {
            return { success: false, score: 50, message: "⚠️ Configuration OK, mais il manque digitalWrite(13, HIGH) pour allumer la LED." };
          } else if (hasDigitalWrite) {
            return { success: false, score: 50, message: "⚠️ digitalWrite présent, mais il manque pinMode(13, OUTPUT) dans setup()." };
          } else {
            return { success: false, score: 0, message: "❌ Il faut pinMode(13, OUTPUT) ET digitalWrite(13, HIGH)" };
          }
        }
      },
      {
        id: 6,
        title: "Faire clignoter une LED",
        difficulty: "Débutant",
        category: "led",
        question: "Écrivez le code pour faire clignoter une LED sur la broche 13 (1 seconde allumée, 1 seconde éteinte).",
        objectives: [
          "Utiliser digitalWrite()",
          "Utiliser delay()",
          "Créer une boucle infinie"
        ],
        type: "code",
        template: "void setup() {\n  // À compléter\n}\n\nvoid loop() {\n  // À compléter\n}",
        solution: "void setup() {\n  pinMode(13, OUTPUT);\n}\n\nvoid loop() {\n  digitalWrite(13, HIGH);\n  delay(1000);\n  digitalWrite(13, LOW);\n  delay(1000);\n}",
        hints: [
          "Allumez avec digitalWrite(13, HIGH)",
          "Attendez 1000 millisecondes avec delay(1000)",
          "Éteignez avec digitalWrite(13, LOW)",
          "Attendez encore 1000 millisecondes"
        ],
        validate: function(code) {
          const hasPinMode = code.includes('pinMode(13, OUTPUT)');
          const hasHigh = code.includes('digitalWrite(13, HIGH)');
          const hasLow = code.includes('digitalWrite(13, LOW)');
          const delays = (code.match(/delay\(1000\)/g) || []).length;
          
          if (hasPinMode && hasHigh && hasLow && delays >= 2) {
            return { success: true, score: 100, message: "✅ Excellent ! LED clignotante parfaite." };
          } else {
            let missing = [];
            if (!hasPinMode) missing.push("pinMode(13, OUTPUT)");
            if (!hasHigh) missing.push("digitalWrite(13, HIGH)");
            if (!hasLow) missing.push("digitalWrite(13, LOW)");
            if (delays < 2) missing.push("deux delay(1000)");
            return { success: false, score: 0, message: "❌ Il manque : " + missing.join(", ") };
          }
        }
      },
      {
        id: 7,
        title: "LED avec PWM (variation luminosité)",
        difficulty: "Intermédiaire",
        category: "led",
        question: "Écrivez le code pour faire varier la luminosité d'une LED sur la broche 9 en utilisant le PWM (analogWrite). La luminosité doit augmenter progressivement de 0 à 255 puis diminuer.",
        objectives: [
          "Utiliser analogWrite()",
          "Créer une boucle for",
          "Faire un effet de respiration"
        ],
        type: "code",
        template: "int ledPin = 9;\n\nvoid setup() {\n  // Configuration\n}\n\nvoid loop() {\n  // Augmenter la luminosité de 0 à 255\n  // Puis diminuer de 255 à 0\n}",
        solution: "int ledPin = 9;\n\nvoid setup() {\n  // Pas de pinMode nécessaire pour PWM\n}\n\nvoid loop() {\n  for (int i = 0; i <= 255; i++) {\n    analogWrite(ledPin, i);\n    delay(10);\n  }\n  for (int i = 255; i >= 0; i--) {\n    analogWrite(ledPin, i);\n    delay(10);\n  }\n}",
        hints: [
          "Utilisez analogWrite(pin, valeur) avec valeur entre 0 et 255",
          "Une boucle for peut augmenter de 0 à 255",
          "Une autre boucle for peut diminuer de 255 à 0",
          "Ajoutez un petit delay pour voir la progression"
        ],
        validate: function(code) {
          const hasAnalogWrite = code.includes('analogWrite(');
          const hasForLoop1 = /for\s*\(.*i.*<=.*255.*i\+\+/.test(code);
          const hasForLoop2 = /for\s*\(.*i.*>=.*0.*i--/.test(code);
          const hasDelay = code.includes('delay(');
          
          if (hasAnalogWrite && hasForLoop1 && hasForLoop2 && hasDelay) {
            return { success: true, score: 100, message: "✅ Super ! Effet PWM parfait." };
          } else {
            return { success: false, score: 0, message: "❌ Vérifiez que vous avez deux boucles for avec analogWrite() et delay()" };
          }
        }
      },

      // === BOUTONS ET ENTRÉES ===
      {
        id: 8,
        title: "Lire un bouton",
        difficulty: "Débutant",
        category: "buttons",
        question: "Écrivez le code pour lire l'état d'un bouton connecté à la broche 2 et allumer une LED sur la broche 13 quand le bouton est pressé. Utilisez une résistance PULL-UP interne.",
        objectives: [
          "Configurer une entrée avec INPUT_PULLUP",
          "Lire un bouton avec digitalRead()",
          "Contrôler une LED avec if/else"
        ],
        type: "code",
        template: "int buttonPin = 2;\nint ledPin = 13;\n\nvoid setup() {\n  // Configuration\n}\n\nvoid loop() {\n  // Lecture et contrôle LED\n}",
        solution: "int buttonPin = 2;\nint ledPin = 13;\n\nvoid setup() {\n  pinMode(ledPin, OUTPUT);\n  pinMode(buttonPin, INPUT_PULLUP);\n}\n\nvoid loop() {\n  int buttonState = digitalRead(buttonPin);\n  if (buttonState == LOW) {\n    digitalWrite(ledPin, HIGH);\n  } else {\n    digitalWrite(ledPin, LOW);\n  }\n}",
        hints: [
          "INPUT_PULLUP active la résistance interne",
          "Le bouton est LOW quand il est pressé (avec PULLUP)",
          "Utilisez digitalRead() pour lire l'état",
          "Une condition if/else contrôle la LED"
        ],
        validate: function(code) {
          const hasPullup = code.includes('INPUT_PULLUP');
          const hasDigitalRead = code.includes('digitalRead(buttonPin)');
          const hasIf = code.includes('if');
          const hasDigitalWrite = code.includes('digitalWrite(ledPin, HIGH)') && code.includes('digitalWrite(ledPin, LOW)');
          
          if (hasPullup && hasDigitalRead && hasIf && hasDigitalWrite) {
            return { success: true, score: 100, message: "✅ Parfait ! Bouton fonctionnel." };
          } else {
            return { success: false, score: 0, message: "❌ Vérifiez la configuration du bouton et la condition if/else." };
          }
        }
      },
      {
        id: 9,
        title: "Anti-rebond logiciel",
        difficulty: "Intermédiaire",
        category: "buttons",
        question: "Un bouton mécanique peut avoir des rebonds. Écrivez le code pour lire un bouton sur la broche 2 avec un anti-rebond simple (delay de 50ms après détection).",
        objectives: [
          "Gérer les rebonds mécaniques",
          "Utiliser un delay pour stabiliser la lecture"
        ],
        type: "code",
        template: "int buttonPin = 2;\nint ledPin = 13;\nint lastState = HIGH;\n\nvoid setup() {\n  pinMode(ledPin, OUTPUT);\n  pinMode(buttonPin, INPUT_PULLUP);\n}\n\nvoid loop() {\n  // À compléter avec anti-rebond\n}",
        solution: "int buttonPin = 2;\nint ledPin = 13;\nint lastState = HIGH;\n\nvoid setup() {\n  pinMode(ledPin, OUTPUT);\n  pinMode(buttonPin, INPUT_PULLUP);\n}\n\nvoid loop() {\n  int currentState = digitalRead(buttonPin);\n  if (currentState != lastState) {\n    delay(50); // Anti-rebond\n    if (currentState == LOW) {\n      digitalWrite(ledPin, !digitalRead(ledPin)); // Bascule\n    }\n    lastState = currentState;\n  }\n}",
        hints: [
          "Détectez un changement d'état",
          "Ajoutez un delay de 50ms après un changement",
          "Relisez l'état après le délai",
          "Faites basculer l'état de la LED"
        ],
        validate: function(code) {
          const hasDelay = code.includes('delay(50)') || code.includes('delay(50);');
          const hasStateChange = code.includes('currentState != lastState') || code.includes('digitalRead');
          
          if (hasDelay && hasStateChange) {
            return { success: true, score: 100, message: "✅ Bonne implémentation de l'anti-rebond !" };
          } else {
            return { success: false, score: 0, message: "❌ Il faut détecter le changement d'état et ajouter un delay(50)" };
          }
        }
      },

      // === COMMUNICATION SÉRIE ===
      {
        id: 10,
        title: "Afficher sur le moniteur série",
        difficulty: "Débutant",
        category: "serial",
        question: "Écrivez le code pour initialiser la communication série à 9600 bauds et afficher 'Hello Arduino!' une seule fois au démarrage.",
        objectives: [
          "Utiliser Serial.begin()",
          "Utiliser Serial.println()"
        ],
        type: "code",
        template: "void setup() {\n  // À compléter\n}\n\nvoid loop() {\n  // Rien ici\n}",
        solution: "void setup() {\n  Serial.begin(9600);\n  Serial.println(\"Hello Arduino!\");\n}\n\nvoid loop() {}",
        hints: [
          "Serial.begin(9600) initialise à 9600 bauds",
          "Serial.println() affiche une ligne",
          "Mettez le texte entre guillemets"
        ],
        validate: function(code) {
          const hasBegin = code.includes('Serial.begin(9600)');
          const hasPrint = code.includes('Serial.println("Hello Arduino!")') || code.includes("Serial.println('Hello Arduino!')");
          
          if (hasBegin && hasPrint) {
            return { success: true, score: 100, message: "✅ Parfait ! Communication série établie." };
          } else {
            return { success: false, score: 0, message: "❌ Il manque Serial.begin(9600) et/ou Serial.println()" };
          }
        }
      },
      {
        id: 11,
        title: "Lire une entrée analogique",
        difficulty: "Intermédiaire",
        category: "serial",
        question: "Écrivez le code pour lire la valeur d'un potentiomètre sur la broche analogique A0 et afficher cette valeur sur le moniteur série toutes les 500ms.",
        objectives: [
          "Utiliser analogRead()",
          "Afficher des valeurs sur le moniteur série",
          "Utiliser delay() pour temporiser"
        ],
        type: "code",
        template: "int potPin = A0;\n\nvoid setup() {\n  // Initialisation\n}\n\nvoid loop() {\n  // Lecture et affichage\n}",
        solution: "int potPin = A0;\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  int value = analogRead(potPin);\n  Serial.println(value);\n  delay(500);\n}",
        hints: [
          "Initialisez le Serial dans setup()",
          "analogRead() retourne une valeur entre 0 et 1023 (ou 0-4095 sur ESP32)",
          "Affichez avec Serial.println()",
          "Ajoutez un delay(500) pour ne pas saturer"
        ],
        validate: function(code) {
          const hasBegin = code.includes('Serial.begin(9600)');
          const hasAnalogRead = code.includes('analogRead(potPin)') || code.includes('analogRead(A0)');
          const hasPrint = code.includes('Serial.println(');
          const hasDelay = code.includes('delay(500)');
          
          if (hasBegin && hasAnalogRead && hasPrint && hasDelay) {
            return { success: true, score: 100, message: "✅ Excellent ! Lecture analogique opérationnelle." };
          } else {
            return { success: false, score: 0, message: "❌ Vérifiez que vous avez tout : Serial.begin, analogRead, Serial.println, delay(500)" };
          }
        }
      },

      // === PLUS DE QUIZ VARIÉS ===
      {
        id: 12,
        title: "Créer une fonction",
        difficulty: "Intermédiaire",
        category: "functions",
        question: "Créez une fonction 'clignoter' qui prend en paramètre le numéro de broche et le délai, et fait clignoter une LED sur cette broche avec ce délai.",
        objectives: [
          "Définir une fonction",
          "Utiliser des paramètres",
          "Réutiliser du code"
        ],
        type: "code",
        template: "// Définissez la fonction clignoter ici\n\nvoid setup() {\n  pinMode(13, OUTPUT);\n}\n\nvoid loop() {\n  clignoter(13, 500); // Appel de la fonction\n}",
        solution: "void clignoter(int pin, int delai) {\n  digitalWrite(pin, HIGH);\n  delay(delai);\n  digitalWrite(pin, LOW);\n  delay(delai);\n}\n\nvoid setup() {\n  pinMode(13, OUTPUT);\n}\n\nvoid loop() {\n  clignoter(13, 500);\n}",
        hints: [
          "Une fonction se définit avec : type nom(paramètres) { ... }",
          "Ici, la fonction ne retourne rien : utilisez 'void'",
          "Paramètres : (int pin, int delai)"
        ],
        validate: function(code) {
          const hasFunction = code.includes('void clignoter(');
          const hasDigitalWrites = code.includes('digitalWrite(pin, HIGH)') && code.includes('digitalWrite(pin, LOW)');
          const hasDelays = code.includes('delay(delai)');
          const hasCall = code.includes('clignoter(13, 500)');
          
          if (hasFunction && hasDigitalWrites && hasDelays && hasCall) {
            return { success: true, score: 100, message: "✅ Superbe fonction !" };
          } else {
            return { success: false, score: 0, message: "❌ La fonction doit s'appeler clignoter, prendre pin et delai, et utiliser digitalWrite/delay" };
          }
        }
      },
      {
        id: 13,
        title: "Tableau de LEDs",
        difficulty: "Intermédiaire",
        category: "led",
        question: "Déclarez un tableau contenant les broches des LEDs : 2, 3, 4, 5. Puis écrivez une boucle pour toutes les configurer en sortie.",
        objectives: [
          "Déclarer un tableau",
          "Utiliser une boucle for",
          "Configurer plusieurs broches"
        ],
        type: "code",
        template: "// Déclarez le tableau leds\n\nvoid setup() {\n  // Boucle pour configurer les broches\n}\n\nvoid loop() {}",
        solution: "int leds[] = {2, 3, 4, 5};\n\nvoid setup() {\n  for (int i = 0; i < 4; i++) {\n    pinMode(leds[i], OUTPUT);\n  }\n}\n\nvoid loop() {}",
        hints: [
          "Un tableau se déclare : type nom[] = {valeurs};",
          "La boucle for : for(int i=0; i<4; i++)",
          "Accès au tableau : leds[i]"
        ],
        validate: function(code) {
          const hasArray = code.includes('int leds[] = {2,3,4,5}') || code.includes('int leds[] = {2, 3, 4, 5}');
          const hasForLoop = /for\s*\(.*i.*<.*4.*i\+\+/.test(code);
          const hasPinMode = code.includes('pinMode(leds[i], OUTPUT)');
          
          if (hasArray && hasForLoop && hasPinMode) {
            return { success: true, score: 100, message: "✅ Tableau et boucle parfaits !" };
          } else {
            return { success: false, score: 0, message: "❌ Vérifiez le tableau et la boucle for" };
          }
        }
      },
      {
        id: 14,
        title: "Structure if/else",
        difficulty: "Débutant",
        category: "structures",
        question: "Écrivez un code qui lit une variable 'temperature'. Si temperature > 25, allumez une LED sur la broche 13, sinon éteignez-la.",
        objectives: [
          "Utiliser if/else",
          "Comparer des valeurs",
          "Contrôler une LED"
        ],
        type: "code",
        template: "int temperature = 30;\nint ledPin = 13;\n\nvoid setup() {\n  pinMode(ledPin, OUTPUT);\n}\n\nvoid loop() {\n  // Votre code ici\n}",
        solution: "int temperature = 30;\nint ledPin = 13;\n\nvoid setup() {\n  pinMode(ledPin, OUTPUT);\n}\n\nvoid loop() {\n  if (temperature > 25) {\n    digitalWrite(ledPin, HIGH);\n  } else {\n    digitalWrite(ledPin, LOW);\n  }\n}",
        hints: [
          "Utilisez if (condition) { ... } else { ... }",
          "Condition : temperature > 25",
          "HIGH pour allumer, LOW pour éteindre"
        ],
        validate: function(code) {
          const hasIf = code.includes('if');
          const hasElse = code.includes('else');
          const hasCondition = code.includes('temperature > 25');
          const hasDigitalWrites = code.includes('digitalWrite(ledPin, HIGH)') && code.includes('digitalWrite(ledPin, LOW)');
          
          if (hasIf && hasElse && hasCondition && hasDigitalWrites) {
            return { success: true, score: 100, message: "✅ Structure conditionnelle correcte !" };
          } else {
            return { success: false, score: 0, message: "❌ Vérifiez la syntaxe if/else et les digitalWrite" };
          }
        }
      },
      {
        id: 15,
        title: "Compteur avec bouton",
        difficulty: "Intermédiaire",
        category: "buttons",
        question: "Réalisez un compteur qui s'incrémente à chaque pression sur un bouton (broche 2). Affichez la valeur du compteur sur le moniteur série.",
        objectives: [
          "Détecter un front descendant",
          "Incrémenter une variable",
          "Éviter les rebonds"
        ],
        type: "code",
        template: "int buttonPin = 2;\nint compteur = 0;\nint lastState = HIGH;\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(buttonPin, INPUT_PULLUP);\n}\n\nvoid loop() {\n  // Votre code ici\n}",
        solution: "int buttonPin = 2;\nint compteur = 0;\nint lastState = HIGH;\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(buttonPin, INPUT_PULLUP);\n}\n\nvoid loop() {\n  int currentState = digitalRead(buttonPin);\n  if (currentState == LOW && lastState == HIGH) {\n    delay(50); // Anti-rebond\n    compteur++;\n    Serial.println(compteur);\n  }\n  lastState = currentState;\n}",
        hints: [
          "Détectez le changement de HIGH à LOW",
          "Ajoutez un petit delay anti-rebond",
          "Incrémentez avec compteur++",
          "Affichez avec Serial.println()"
        ],
        validate: function(code) {
          const hasStateDetection = code.includes('currentState == LOW && lastState == HIGH');
          const hasIncrement = code.includes('compteur++');
          const hasPrint = code.includes('Serial.println(compteur)');
          const hasDelay = code.includes('delay(50)');
          
          if (hasStateDetection && hasIncrement && hasPrint && hasDelay) {
            return { success: true, score: 100, message: "✅ Excellent compteur !" };
          } else {
            return { success: false, score: 0, message: "❌ Détection d'appui ou incrémentation incorrecte" };
          }
        }
      },
      {
        id: 16,
        title: "Utilisation de millis()",
        difficulty: "Avancé",
        category: "timing",
        question: "Utilisez millis() pour faire clignoter une LED sur la broche 13 sans utiliser delay(). La LED doit changer d'état toutes les 500ms.",
        objectives: [
          "Comprendre millis()",
          "Éviter de bloquer le programme",
          "Gérer le temps sans delay"
        ],
        type: "code",
        template: "int ledPin = 13;\nint ledState = LOW;\nunsigned long previousMillis = 0;\nconst long interval = 500;\n\nvoid setup() {\n  pinMode(ledPin, OUTPUT);\n}\n\nvoid loop() {\n  // Votre code avec millis()\n}",
        solution: "int ledPin = 13;\nint ledState = LOW;\nunsigned long previousMillis = 0;\nconst long interval = 500;\n\nvoid setup() {\n  pinMode(ledPin, OUTPUT);\n}\n\nvoid loop() {\n  unsigned long currentMillis = millis();\n  if (currentMillis - previousMillis >= interval) {\n    previousMillis = currentMillis;\n    ledState = !ledState;\n    digitalWrite(ledPin, ledState);\n  }\n}",
        hints: [
          "millis() retourne le temps depuis le démarrage",
          "Comparez currentMillis - previousMillis avec interval",
          "Changez l'état avec ledState = !ledState"
        ],
        validate: function(code) {
          const hasMillis = code.includes('millis()');
          const hasComparison = code.includes('currentMillis - previousMillis >= interval');
          const hasStateChange = code.includes('ledState = !ledState');
          const hasDigitalWrite = code.includes('digitalWrite(ledPin, ledState)');
          
          if (hasMillis && hasComparison && hasStateChange && hasDigitalWrite) {
            return { success: true, score: 100, message: "✅ Parfait ! Timing non bloquant avec millis()." };
          } else {
            return { success: false, score: 0, message: "❌ Structure millis() incorrecte" };
          }
        }
      }
    ];

    // ==================== FONCTIONS UTILITAIRES ====================
    function removeCommentsAndWhitespace(text) {
      if (!text) return '';
      let result = text.replace(/\/\/.*$/gm, '');
      result = result.replace(/\/\*[\s\S]*?\*\//g, '');
      result = result.replace(/\s/g, '');
      return result;
    }

    // ==================== AFFICHAGE DES QUIZ ====================
    function displayQuizzes(category = 'all') {
      const grid = document.getElementById('quiz-grid');
      if (!grid) return;
      
      let filtered = quizzes;
      if (category !== 'all') {
        filtered = quizzes.filter(q => q.category === category || q.difficulty.toLowerCase() === category);
      }
      
      grid.innerHTML = '';
      filtered.forEach(quiz => {
        const completed = completedQuizzes.includes(quiz.id);
        const card = document.createElement('div');
        card.className = 'quiz-card';
        card.onclick = () => loadQuiz(quiz.id);
        
        card.innerHTML = `
          <div class="quiz-header">
            <h3>${quiz.title}</h3>
            <span class="quiz-difficulty difficulty-${quiz.difficulty.toLowerCase()}">${quiz.difficulty}</span>
          </div>
          <div class="quiz-body">
            <div class="quiz-question">${quiz.question.substring(0, 100)}${quiz.question.length > 100 ? '...' : ''}</div>
            <div class="quiz-tags">
              <span class="tag">${quiz.category}</span>
            </div>
            <div class="quiz-status">
              <span style="color: ${completed ? 'var(--success-color)' : '#6c757d'}">
                <i class="fas ${completed ? 'fa-check-circle' : 'fa-circle'}"></i> 
                ${completed ? 'Complété' : 'Non tenté'}
              </span>
              <span><i class="fas fa-clock"></i> ~5 min</span>
            </div>
          </div>
        `;
        grid.appendChild(card);
      });
    }

    // ==================== CHARGEMENT D'UN QUIZ ====================
    function loadQuiz(id) {
      const quiz = quizzes.find(q => q.id === id);
      if (!quiz) return;
      
      currentQuiz = quiz;
      
      document.getElementById('quiz-workspace').style.display = 'block';
      document.getElementById('workspace-title').textContent = `Quiz #${quiz.id}: ${quiz.title}`;
      document.getElementById('question-text').textContent = quiz.question;
      
      const objList = document.getElementById('objective-list');
      objList.innerHTML = '';
      quiz.objectives.forEach(obj => {
        const li = document.createElement('li');
        li.textContent = obj;
        objList.appendChild(li);
      });
      
      if (quiz.type === 'code') {
        document.getElementById('options-container').style.display = 'none';
        document.getElementById('code-input').style.display = 'block';
        document.getElementById('code-input').value = quiz.template || '';
        document.getElementById('code-filename').textContent = `quiz${quiz.id}.ino`;
      } else {
        document.getElementById('code-input').style.display = 'none';
        document.getElementById('options-container').style.display = 'flex';
        
        const optionsHtml = quiz.options.map((opt, idx) => `
          <label class="option-item">
            <input type="radio" name="quiz-option" value="${idx}">
            <span class="option-text">${opt}</span>
          </label>
        `).join('');
        document.getElementById('options-container').innerHTML = optionsHtml;
      }
      
      document.getElementById('feedback-area').classList.remove('show');
      document.getElementById('quiz-workspace').scrollIntoView({ behavior: 'smooth' });
    }

    // ==================== VALIDATION D'UN QUIZ ====================
    function validateQuiz() {
      if (!currentQuiz) return;
      
      let result;
      
      if (currentQuiz.type === 'code') {
        const code = document.getElementById('code-input').value;
        result = currentQuiz.validate(code);
      } else {
        const selected = document.querySelector('input[name="quiz-option"]:checked');
        if (!selected) {
          notifyWarning('Veuillez sélectionner une réponse');
          return;
        }
        const isCorrect = currentQuiz.validate(parseInt(selected.value));
        result = {
          success: isCorrect,
          score: isCorrect ? 100 : 0,
          message: isCorrect ? '✅ Bonne réponse !' : '❌ Mauvaise réponse, réessayez.'
        };
      }
      
      const feedbackArea = document.getElementById('feedback-area');
      const feedbackContent = document.getElementById('feedback-content');
      const feedbackTitle = document.getElementById('feedback-title');
      const feedbackIcon = document.getElementById('feedback-icon');
      
      if (result.success) {
        feedbackTitle.textContent = 'Succès !';
        feedbackIcon.className = 'fas fa-check-circle';
        feedbackIcon.style.color = 'var(--success-color)';
        
        if (!completedQuizzes.includes(currentQuiz.id)) {
          completedQuizzes.push(currentQuiz.id);
          localStorage.setItem('completedQuizzes', JSON.stringify(completedQuizzes));
          updateProgress();
          showAchievement(`Quiz #${currentQuiz.id} réussi !`);
        }
      } else {
        feedbackTitle.textContent = 'À améliorer';
        feedbackIcon.className = 'fas fa-exclamation-triangle';
        feedbackIcon.style.color = 'var(--warning-color)';
      }
      
      let feedback = `<p class="${result.success ? 'feedback-success' : 'feedback-error'}">${result.message}</p>`;
      feedback += `<p>Score : ${result.score}%</p>`;
      
      if (!result.success && currentQuiz.hints) {
        feedback += '<div class="feedback-hint"><h5><i class="fas fa-lightbulb"></i> Indices :</h5><ul>';
        currentQuiz.hints.forEach(hint => {
          feedback += `<li>${hint}</li>`;
        });
        feedback += '</ul></div>';
      }
      
      if (!result.success && currentQuiz.solution) {
        feedback += '<div class="feedback-hint"><h5>Solution :</h5>';
        feedback += `<pre class="code-block">${currentQuiz.solution}</pre>`;
        feedback += '</div>';
      }
      
      feedbackContent.innerHTML = feedback;
      feedbackArea.classList.add('show');
    }

    // ==================== AUTRES FONCTIONS ====================
    function showHint() {
      if (!currentQuiz) return;
      
      const feedbackArea = document.getElementById('feedback-area');
      const feedbackContent = document.getElementById('feedback-content');
      const feedbackTitle = document.getElementById('feedback-title');
      const feedbackIcon = document.getElementById('feedback-icon');
      
      feedbackTitle.textContent = 'Indices';
      feedbackIcon.className = 'fas fa-lightbulb';
      feedbackIcon.style.color = 'var(--warning-color)';
      
      let html = '<div class="feedback-hint"><ul>';
      currentQuiz.hints.forEach(hint => {
        html += `<li>${hint}</li>`;
      });
      html += '</ul></div>';
      
      feedbackContent.innerHTML = html;
      feedbackArea.classList.add('show');
    }

    function resetQuiz() {
      if (!currentQuiz) return;
      document.getElementById('code-input').value = currentQuiz.template || '';
      document.getElementById('feedback-area').classList.remove('show');
    }

    function closeWorkspace() {
      document.getElementById('quiz-workspace').style.display = 'none';
      currentQuiz = null;
    }

    function filterQuizzes(category) {
      document.querySelectorAll('.category-btn').forEach(btn => btn.classList.remove('active'));
      event.target.classList.add('active');
      displayQuizzes(category);
    }

    function updateProgress() {
      const total = quizzes.length;
      const completed = completedQuizzes.length;
      const percent = (completed / total) * 100;
      
      document.getElementById('progress-text').textContent = `${completed}/${total} quiz complétés`;
      document.getElementById('progress-bar').style.width = `${percent}%`;
      
      // Mise à jour des statuts dans la grille
      displayQuizzes();
    }

    function showAchievement(message) {
      const banner = document.getElementById('achievement-banner');
      document.getElementById('achievement-message').textContent = message;
      banner.style.display = 'block';
      setTimeout(hideAchievement, 3000);
    }

    function hideAchievement() {
      document.getElementById('achievement-banner').style.display = 'none';
    }
// ==================== BASE DE DONNÉES DES QUESTIONS INDIVIDUELLES ====================
const individualQuestions = [
  {
    id: 1,
    category: "Bases Arduino",
    question: "Quelles sont les fonctions obligatoires dans tout programme Arduino ?",
    options: [
      "setup()",
      "loop()",
      "main()",
      "init()"
    ],
    correct: [0, 1], // setup() ET loop() sont obligatoires
    type: "multiple",
    explanation: "Tout programme Arduino doit obligatoirement avoir les fonctions setup() (exécutée une fois au démarrage) et loop() (exécutée en boucle).",
    hint: "Pensez à la structure de base d'un programme Arduino"
  },
  {
    id: 2,
    category: "LED",
    question: "Quelle broche est utilisée pour la LED intégrée sur la plupart des cartes Arduino ?",
    options: [
      "13",
      "12",
      "A0",
      "5V"
    ],
    correct: [0],
    type: "single",
    explanation: "La broche 13 est connectée à la LED intégrée sur la plupart des cartes Arduino (Uno, Mega, etc.).",
    hint: "C'est la broche avec la LED sur la carte"
  },
  {
    id: 3,
    category: "Sorties",
    question: "Quelles fonctions utilise-t-on pour contrôler une sortie numérique ?",
    options: [
      "digitalWrite()",
      "analogWrite()",
      "pinMode()",
      "digitalRead()"
    ],
    correct: [0, 2], // pinMode ET digitalWrite
    type: "multiple",
    explanation: "Il faut d'abord configurer la broche avec pinMode(), puis envoyer le signal avec digitalWrite().",
    hint: "Configuration d'abord, puis action"
  },
  {
    id: 4,
    category: "PWM",
    question: "Quelle est la valeur maximale que peut prendre analogWrite() sur Arduino ?",
    options: [
      "255",
      "1023",
      "4095",
      "100"
    ],
    correct: [0],
    type: "single",
    explanation: "analogWrite() accepte des valeurs de 0 à 255 pour le PWM (8 bits).",
    hint: "C'est une valeur de 8 bits"
  },
  {
    id: 5,
    category: "Variables",
    question: "Quels sont les types de données valides en Arduino ?",
    options: [
      "int",
      "float",
      "string",
      "boolean",
      "char"
    ],
    correct: [0, 1, 3, 4], // int, float, boolean, char (string n'existe pas)
    type: "multiple",
    explanation: "Les types valides sont int, float, boolean, char. Pour les chaînes, on utilise String (avec majuscule).",
    hint: "string (minuscule) n'existe pas en Arduino"
  },
  {
    id: 6,
    category: "Constantes",
    question: "Comment déclare-t-on une constante en Arduino ? (plusieurs réponses possibles)",
    options: [
      "const int PIN = 13;",
      "#define PIN 13",
      "int PIN = 13;",
      "constant int PIN = 13;"
    ],
    correct: [0, 1],
    type: "multiple",
    explanation: "On peut utiliser 'const' ou '#define' pour créer des constantes. '#define' est traité avant la compilation.",
    hint: "Deux façons de faire en C++"
  },
  {
    id: 7,
    category: "Boucles",
    question: "Quelles structures permettent de répéter du code ?",
    options: [
      "for",
      "while",
      "if",
      "switch"
    ],
    correct: [0, 1],
    type: "multiple",
    explanation: "for et while sont des boucles. if et switch sont des structures conditionnelles.",
    hint: "Les boucles répètent, les conditions testent"
  },
  {
    id: 8,
    category: "Temporisation",
    question: "Que signifie 'delay(1000)' ?",
    options: [
      "Attendre 1 seconde",
      "Attendre 1000 secondes",
      "Attendre 1 milliseconde",
      "Exécuter 1000 fois"
    ],
    correct: [0],
    type: "single",
    explanation: "delay(1000) arrête le programme pendant 1000 millisecondes, soit 1 seconde.",
    hint: "1000 millisecondes = 1 seconde"
  },
  {
    id: 9,
    category: "Booléens",
    question: "Quelles sont les valeurs possibles pour une variable booléenne ?",
    options: [
      "true",
      "false",
      "HIGH",
      "LOW",
      "1",
      "0"
    ],
    correct: [0, 1, 4, 5],
    type: "multiple",
    explanation: "Un booléen peut être true/false ou 1/0. HIGH/LOW sont pour les broches, pas pour les booléens.",
    hint: "Les valeurs binaires de base"
  },
  {
    id: 10,
    category: "Communication série",
    question: "Quelle fonction initialise la communication série ?",
    options: [
      "Serial.begin()",
      "Serial.start()",
      "Serial.init()",
      "Serial.setup()"
    ],
    correct: [0],
    type: "single",
    explanation: "Serial.begin(9600) initialise la communication série à 9600 bauds.",
    hint: "begin comme 'commencer'"
  },
  {
    id: 11,
    category: "Affichage série",
    question: "Quelles fonctions permettent d'envoyer des données sur le port série ?",
    options: [
      "Serial.print()",
      "Serial.println()",
      "Serial.write()",
      "Serial.send()"
    ],
    correct: [0, 1, 2],
    type: "multiple",
    explanation: "print(), println() et write() sont les trois fonctions pour envoyer des données série.",
    hint: "Toutes sauf send()"
  },
  {
    id: 12,
    category: "PWM",
    question: "Quelles broches supportent le PWM sur Arduino UNO ?",
    options: [
      "3, 5, 6, 9, 10, 11",
      "Toutes les broches",
      "A0 à A5",
      "0 à 13"
    ],
    correct: [0],
    type: "single",
    explanation: "Sur Arduino UNO, les broches PWM sont 3, 5, 6, 9, 10 et 11 (marquées du symbole ~).",
    hint: "Cherchez les broches avec un ~ sur la carte"
  },
  {
    id: 13,
    category: "LED",
    question: "Comment allumer une LED sur la broche 13 ?",
    options: [
      "digitalWrite(13, HIGH);",
      "analogWrite(13, 255);",
      "digitalWrite(13, 1);",
      "pinMode(13, HIGH);"
    ],
    correct: [0, 2],
    type: "multiple",
    explanation: "HIGH et 1 sont équivalents pour digitalWrite. analogWrite(13, 255) fonctionnerait aussi si la broche supporte le PWM.",
    hint: "HIGH ou 1 sont corrects"
  },
  {
    id: 14,
    category: "Boutons",
    question: "Comment configurer une broche en entrée avec résistance pull-up interne ?",
    options: [
      "pinMode(pin, INPUT_PULLUP);",
      "pinMode(pin, INPUT);",
      "digitalWrite(pin, HIGH);",
      "pinMode(pin, INPUT_PULLDOWN);"
    ],
    correct: [0],
    type: "single",
    explanation: "INPUT_PULLUP active la résistance pull-up interne du microcontrôleur.",
    hint: "C'est une constante spéciale"
  },
  {
    id: 15,
    category: "Boutons",
    question: "Que retourne digitalRead() quand un bouton est pressé (avec pull-up) ?",
    options: [
      "LOW",
      "HIGH",
      "0",
      "1"
    ],
    correct: [0, 2],
    type: "multiple",
    explanation: "Avec une résistance pull-up, le bouton est normalement HIGH et devient LOW quand il est pressé. LOW et 0 sont équivalents.",
    hint: "Le signal passe de 1 à 0"
  }
];

// État des réponses pour chaque question
let questionAnswers = {};
let questionValidationStatus = {};

// Initialiser
individualQuestions.forEach(q => {
  questionAnswers[q.id] = [];
  questionValidationStatus[q.id] = false; // non validée
});

// ==================== AFFICHER LES QUESTIONS INDIVIDUELLES ====================
function displayIndividualQuestions() {
  const container = document.getElementById('multiple-choice-quiz-container');
  if (!container) return;
  
  let html = '';
  
  // Grouper par catégorie pour meilleure organisation
  const categories = {};
  individualQuestions.forEach(q => {
    if (!categories[q.category]) categories[q.category] = [];
    categories[q.category].push(q);
  });
  
  for (let category in categories) {
    html += `
      <div style="margin: 2rem 0; background-color: white; border-radius: 12px; overflow: hidden; box-shadow: 0 6px 15px rgba(0,0,0,0.1);">
        <div style="background-color: var(--primary-color); color: white; padding: 1rem;">
          <h3 style="margin: 0;"><i class="fas fa-folder"></i> ${category}</h3>
        </div>
        <div style="padding: 1.5rem;">
    `;
    
    categories[category].forEach((question, index) => {
      const isValidated = questionValidationStatus[question.id];
      const isCorrect = isValidated && checkQuestionAnswer(question.id);
      
      html += `
        <div class="question-card" id="question-card-${question.id}" style="
          margin-bottom: 2rem;
          padding: 1.5rem;
          background-color: #f8f9fa;
          border-radius: 8px;
          border-left: 5px solid ${isValidated ? (isCorrect ? 'var(--success-color)' : 'var(--danger-color)') : '#ccc'};
          transition: all 0.3s;
        ">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
            <h4 style="color: var(--primary-color); margin: 0;">
              Question ${index + 1}: ${question.question}
            </h4>
            <span style="
              background-color: ${question.type === 'multiple' ? '#ff9800' : '#28a745'};
              color: white;
              padding: 0.2rem 1rem;
              border-radius: 20px;
              font-size: 0.8rem;
            ">
              ${question.type === 'multiple' ? 'Plusieurs réponses' : 'Une seule réponse'}
            </span>
          </div>
          
          <div class="options-container" style="margin: 1.5rem 0;">
      `;
      
      question.options.forEach((option, oIndex) => {
        const isChecked = questionAnswers[question.id]?.includes(oIndex) || false;
        const isDisabled = isValidated; // Désactiver si déjà validé
        
        html += `
          <label class="option-item" style="
            margin-bottom: 0.5rem;
            opacity: ${isDisabled ? 0.6 : 1};
            cursor: ${isDisabled ? 'not-allowed' : 'pointer'};
            background-color: ${isChecked && isValidated ? (isCorrect ? '#d4edda' : '#f8d7da') : ''};
            border-color: ${isChecked && isValidated ? (isCorrect ? 'var(--success-color)' : 'var(--danger-color)') : ''};
          ">
            <input 
              type="${question.type === 'multiple' ? 'checkbox' : 'radio'}" 
              name="question-${question.id}" 
              value="${oIndex}"
              ${isChecked ? 'checked' : ''}
              ${isDisabled ? 'disabled' : ''}
              onchange="handleQuestionAnswer(${question.id}, ${oIndex}, ${question.type === 'multiple'})"
            >
            <span class="option-text">${option}</span>
          </label>
        `;
      });
      
      html += `
          </div>
          
          <div style="display: flex; gap: 10px; justify-content: flex-end;">
            <button class="control-btn hint" onclick="showQuestionHint(${question.id})" style="background-color: var(--warning-color);">
              <i class="fas fa-lightbulb"></i> Indice
            </button>
            <button class="control-btn validate" onclick="validateQuestion(${question.id})" 
              style="background-color: ${isValidated ? (isCorrect ? 'var(--success-color)' : 'var(--danger-color)') : 'var(--success-color)'};"
              ${isValidated ? 'disabled' : ''}>
              <i class="fas ${isValidated ? 'fa-check-circle' : 'fa-check-double'}"></i>
              ${isValidated ? (isCorrect ? 'Correct !' : 'Faux') : 'Valider cette réponse'}
            </button>
          </div>
          
          ${isValidated ? `
            <div style="margin-top: 1rem; padding: 1rem; background-color: white; border-radius: 5px;">
              <p style="color: ${isCorrect ? 'var(--success-color)' : 'var(--danger-color)'}; font-weight: bold;">
                <i class="fas ${isCorrect ? 'fa-check-circle' : 'fa-times-circle'}"></i>
                ${isCorrect ? '✅ Bonne réponse !' : '❌ Mauvaise réponse'}
              </p>
              <p><strong>Explication :</strong> ${question.explanation}</p>
            </div>
          ` : ''}
          
        </div>
      `;
    });
    
    html += `</div></div>`;
  }
  
  container.innerHTML = html;
  updateGlobalScore();
}

// ==================== GÉRER LES RÉPONSES ====================
function handleQuestionAnswer(questionId, optionIndex, isMultiple) {
  if (questionValidationStatus[questionId]) return; // Déjà validé
  
  if (!questionAnswers[questionId]) {
    questionAnswers[questionId] = [];
  }
  
  if (isMultiple) {
    // Mode checkbox
    if (event.target.checked) {
      if (!questionAnswers[questionId].includes(optionIndex)) {
        questionAnswers[questionId].push(optionIndex);
      }
    } else {
      questionAnswers[questionId] = questionAnswers[questionId].filter(
        idx => idx !== optionIndex
      );
    }
  } else {
    // Mode radio - une seule réponse
    questionAnswers[questionId] = [optionIndex];
  }
}

// ==================== VALIDER UNE QUESTION SPÉCIFIQUE ====================
function validateQuestion(questionId) {
  if (questionValidationStatus[questionId]) {
    notifyWarning('Cette question a déjà été validée !');
    return;
  }
  
  const question = individualQuestions.find(q => q.id === questionId);
  if (!question) return;
  
  const userAnswers = questionAnswers[questionId] || [];
  const correctSet = new Set(question.correct);
  const userSet = new Set(userAnswers);
  
  // Vérifier si les ensembles sont identiques
  const isCorrect = 
    userSet.size === correctSet.size && 
    [...userSet].every(value => correctSet.has(value));
  
  // Marquer comme validé
  questionValidationStatus[questionId] = true;
  
  // Sauvegarder l'état
  saveProgress();
  
  // Recharger l'affichage
  displayIndividualQuestions();
  
  // Afficher un message
  if (isCorrect) {
    showAchievement(`✅ Question ${questionId} : Bonne réponse !`);
  } else {
    showAchievement(`❌ Question ${questionId} : Mauvaise réponse, regardez l'explication`);
  }
  
  updateGlobalScore();
}

// ==================== VÉRIFIER UNE QUESTION ====================
function checkQuestionAnswer(questionId) {
  const question = individualQuestions.find(q => q.id === questionId);
  if (!question) return false;
  
  const userAnswers = questionAnswers[questionId] || [];
  const correctSet = new Set(question.correct);
  const userSet = new Set(userAnswers);
  
  return userSet.size === correctSet.size && 
         [...userSet].every(value => correctSet.has(value));
}

// ==================== AFFICHER L'INDICE ====================
function showQuestionHint(questionId) {
  const question = individualQuestions.find(q => q.id === questionId);
  if (!question) return;
  
  notifyInfo(`💡 Indice : ${question.hint}`);
}

// ==================== METTRE À JOUR LE SCORE GLOBAL ====================
function updateGlobalScore() {
  const total = individualQuestions.length;
  let correct = 0;
  
  individualQuestions.forEach(q => {
    if (questionValidationStatus[q.id] && checkQuestionAnswer(q.id)) {
      correct++;
    }
  });
  
  const percentage = Math.round((correct / total) * 100);
  
  document.getElementById('global-score').textContent = `${correct}/${total} questions réussies`;
  document.getElementById('global-progress-bar').style.width = `${percentage}%`;
}

// ==================== RÉINITIALISER TOUTES LES QUESTIONS ====================
function resetAllQuestions() {
  if (confirm('Voulez-vous vraiment réinitialiser toutes les questions ?')) {
    // Réinitialiser les réponses
    questionAnswers = {};
    questionValidationStatus = {};
    
    individualQuestions.forEach(q => {
      questionAnswers[q.id] = [];
      questionValidationStatus[q.id] = false;
    });
    
    // Sauvegarder
    saveProgress();
    
    // Réafficher
    displayIndividualQuestions();
    
    showAchievement('Toutes les questions ont été réinitialisées');
  }
}

// ==================== RÉINITIALISER UNE QUESTION ====================
function resetQuestion(questionId) {
  questionAnswers[questionId] = [];
  questionValidationStatus[questionId] = false;
  
  // Mettre à jour l'affichage
  const card = document.getElementById(`question-card-${questionId}`);
  if (card) {
    card.style.borderLeftColor = '#ccc';
    
    // Réactiver les inputs
    const inputs = card.querySelectorAll('input');
    inputs.forEach(input => {
      input.disabled = false;
      input.checked = false;
    });
    
    // Retirer l'explication
    const explanationDiv = card.querySelector('div[style*="margin-top: 1rem;"]');
    if (explanationDiv) explanationDiv.remove();
    
    // Changer le bouton
    const validateBtn = card.querySelector('button.validate');
    if (validateBtn) {
      validateBtn.disabled = false;
      validateBtn.innerHTML = '<i class="fas fa-check-double"></i> Valider cette réponse';
      validateBtn.style.backgroundColor = 'var(--success-color)';
    }
  }
  
  saveProgress();
  updateGlobalScore();
}

// ==================== AJOUTER UN BOUTON DE RÉINITIALISATION INDIVIDUEL ====================
function addResetButtonToQuestions() {
  // Cette fonction sera appelée après display
  document.querySelectorAll('.question-card').forEach(card => {
    const questionId = card.id.replace('question-card-', '');
    const controls = card.querySelector('div[style*="display: flex; gap: 10px; justify-content: flex-end;"]');
    
    if (controls && !controls.querySelector('.reset-single')) {
      const resetBtn = document.createElement('button');
      resetBtn.className = 'control-btn reset reset-single';
      resetBtn.style.backgroundColor = 'var(--gray-color)';
      resetBtn.innerHTML = '<i class="fas fa-undo"></i> Réinitialiser';
      resetBtn.onclick = () => resetQuestion(parseInt(questionId));
      controls.appendChild(resetBtn);
    }
  });
}

// ==================== SAUVEGARDER LA PROGRESSION ====================
function saveProgress() {
  const progress = {
    answers: questionAnswers,
    validation: questionValidationStatus
  };
  localStorage.setItem('individualQuizProgress', JSON.stringify(progress));
}

// ==================== CHARGER LA PROGRESSION ====================
function loadProgress() {
  const saved = localStorage.getItem('individualQuizProgress');
  if (saved) {
    try {
      const progress = JSON.parse(saved);
      questionAnswers = progress.answers || {};
      questionValidationStatus = progress.validation || {};
      
      // S'assurer que toutes les questions sont initialisées
      individualQuestions.forEach(q => {
        if (!questionAnswers[q.id]) questionAnswers[q.id] = [];
        if (questionValidationStatus[q.id] === undefined) questionValidationStatus[q.id] = false;
      });
    } catch (e) {
      console.error('Erreur chargement progression', e);
    }
  }
}

// ==================== STYLES SUPPLÉMENTAIRES ====================
function addQuestionStyles() {
  const style = document.createElement('style');
  style.textContent = `
    .question-card {
      transition: all 0.3s ease;
    }
    
    .question-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0,0,0,0.1);
    }
    
    .option-item input:disabled + .option-text {
      color: #999;
    }
    
    .control-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .reset-single {
      margin-left: auto;
    }
  `;
  document.head.appendChild(style);
}

// ==================== INITIALISATION ====================
document.addEventListener('DOMContentLoaded', function() {
  // Gardez votre code existant et AJOUTEZ :
  addQuestionStyles();
  loadProgress();
  displayIndividualQuestions();
  
  // Ajouter les boutons de réinitialisation
  setTimeout(addResetButtonToQuestions, 100);
  
  // Statistiques
  console.log(`${individualQuestions.length} questions disponibles`);
});
    // ==================== INITIALISATION ====================

// CORRECTION DU MENU HAMBURGER - Version optimisée
document.addEventListener('DOMContentLoaded', function() {
  displayQuizzes();
  updateProgress();
  
  // Menu hamburger
  const hamburgerBtn = document.querySelector('.hamburger-btn');
  const nav = document.querySelector('nav');
  let mobileOverlay = document.querySelector('.mobile-overlay');
  
  if (!mobileOverlay) {
    mobileOverlay = document.createElement('div');
    mobileOverlay.className = 'mobile-overlay';
    document.body.appendChild(mobileOverlay);
  }
  
  // FORCER LES STYLES CORRECTS POUR L'OVERLAY
  mobileOverlay.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    z-index: 999;
    display: none;
    opacity: 0;
    transition: opacity 0.3s ease;
    pointer-events: none;
  `;

  // FORCER LES STYLES CORRECTS POUR LE NAV EN MOBILE
  function applyMobileStyles() {
    if (window.innerWidth <= 768) {
      nav.style.position = 'fixed';
      nav.style.top = '70px';
      nav.style.left = '-280px';
      nav.style.width = '280px';
      nav.style.height = 'calc(100vh - 70px)';
      nav.style.backgroundColor = 'var(--primary-color)';
      nav.style.transition = 'left 0.3s ease';
      nav.style.zIndex = '1000';
      nav.style.overflowY = 'auto';
      nav.style.boxShadow = '2px 0 10px rgba(0,0,0,0.1)';
      
      // Style des liens
      document.querySelectorAll('.nav-menu a').forEach(link => {
        link.style.display = 'block';
        link.style.padding = '15px 20px';
        link.style.color = 'white';
        link.style.borderBottom = '1px solid rgba(255,255,255,0.1)';
      });
    } else {
      // Reset pour desktop
      nav.style.position = '';
      nav.style.top = '';
      nav.style.left = '';
      nav.style.width = '';
      nav.style.height = '';
      nav.style.backgroundColor = '';
      nav.style.transition = '';
      nav.style.zIndex = '';
      nav.style.overflowY = '';
      nav.style.boxShadow = '';
    }
  }

  applyMobileStyles();

  function toggleMenu() {
    const isActive = nav.classList.contains('active');
    
    if (!isActive) {
      // Ouvrir le menu
      nav.classList.add('active');
      nav.style.left = '0';
      mobileOverlay.style.display = 'block';
      setTimeout(() => {
        mobileOverlay.style.opacity = '1';
        mobileOverlay.style.pointerEvents = 'auto';
      }, 10);
      document.body.style.overflow = 'hidden';
      hamburgerBtn.classList.add('active');
      hamburgerBtn.innerHTML = '<i class="fas fa-times"></i>';
    } else {
      // Fermer le menu
      nav.classList.remove('active');
      nav.style.left = '-280px';
      mobileOverlay.style.opacity = '0';
      mobileOverlay.style.pointerEvents = 'none';
      setTimeout(() => {
        mobileOverlay.style.display = 'none';
      }, 300);
      document.body.style.overflow = '';
      hamburgerBtn.classList.remove('active');
      hamburgerBtn.innerHTML = '<i class="fas fa-bars"></i>';
    }
  }

  // Event listeners
  hamburgerBtn.addEventListener('click', function(e) {
    e.preventDefault();
    e.stopPropagation();
    toggleMenu();
  });

  mobileOverlay.addEventListener('click', function() {
    if (nav.classList.contains('active')) {
      toggleMenu();
    }
  });

  // Fermer avec les liens du menu
  document.querySelectorAll('.nav-menu a').forEach(link => {
    link.addEventListener('click', function() {
      if (window.innerWidth <= 768 && nav.classList.contains('active')) {
        setTimeout(() => toggleMenu(), 150);
      }
    });
  });

  // Touche Echap
  document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape' && nav.classList.contains('active')) {
      toggleMenu();
    }
  });

  // Redimensionnement
  window.addEventListener('resize', function() {
    applyMobileStyles();
    if (window.innerWidth > 768) {
      nav.classList.remove('active');
      nav.style.left = '';
      mobileOverlay.style.display = 'none';
      mobileOverlay.style.opacity = '0';
      mobileOverlay.style.pointerEvents = 'none';
      document.body.style.overflow = '';
      hamburgerBtn.classList.remove('active');
      hamburgerBtn.innerHTML = '<i class="fas fa-bars"></i>';
    }
  });

  // AJOUTER CE CSS POUR RÉSOUDRE LES PROBLÈMES D'OPACITÉ
  const style = document.createElement('style');
  style.textContent = `
    /* Reset des styles existants qui causent des problèmes */
    .mobile-overlay {
      display: none !important;
    }
    
    .mobile-overlay.active {
      display: block !important;
      opacity: 1 !important;
      pointer-events: auto !important;
    }
    
    /* S'assurer que le contenu principal n'est pas affecté */
    .main-content, .hero, header {
      transition: none !important;
      filter: none !important;
      opacity: 1 !important;
    }
    
    /* Style spécifique pour mobile */
    @media (max-width: 768px) {
      .hamburger-btn {
        display: block !important;
        background: none;
        border: none;
        color: white;
        font-size: 24px;
        cursor: pointer;
        z-index: 1001;
        position: relative;
      }
      
      nav.active + * {
        filter: none !important;
        opacity: 1 !important;
      }
      
      /* Empêcher le contenu de devenir transparent */
      body:has(nav.active) .container {
        opacity: 1 !important;
        filter: none !important;
      }
      
      /* Correction pour le header */
      header {
        position: sticky;
        z-index: 1001;
      }
    }
  `;
  document.head.appendChild(style);
});
    // ==================== SYSTÈME DE NOTIFICATION MODERNE ====================
function showNotification(message, type = 'info', duration = 3000) {
  // Créer l'élément de notification s'il n'existe pas
  let notification = document.getElementById('custom-notification');
  if (!notification) {
    notification = document.createElement('div');
    notification.id = 'custom-notification';
    document.body.appendChild(notification);
    
    // Ajouter les styles
    const style = document.createElement('style');
    style.textContent = `
      #custom-notification {
        position: fixed;
        top: 100px;
        right: 20px;
        min-width: 300px;
        max-width: 400px;
        padding: 1rem 1.5rem;
        border-radius: 10px;
        color: white;
        font-weight: 500;
        box-shadow: 0 10px 25px rgba(0,0,0,0.2);
        z-index: 9999;
        transform: translateX(120%);
        transition: transform 0.3s ease;
        display: flex;
        align-items: center;
        gap: 12px;
        backdrop-filter: blur(5px);
      }
      
      #custom-notification.show {
        transform: translateX(0);
      }
      
      #custom-notification i {
        font-size: 1.5rem;
      }
      
      #custom-notification .notification-content {
        flex: 1;
      }
      
      #custom-notification .notification-title {
        font-size: 1rem;
        font-weight: bold;
        margin-bottom: 4px;
      }
      
      #custom-notification .notification-message {
        font-size: 0.9rem;
        opacity: 0.9;
      }
      
      #custom-notification .close-btn {
        background: none;
        border: none;
        color: white;
        cursor: pointer;
        font-size: 1.2rem;
        opacity: 0.7;
        transition: opacity 0.3s;
        padding: 0 5px;
      }
      
      #custom-notification .close-btn:hover {
        opacity: 1;
      }
      
      #custom-notification.info {
        background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
        border-left: 5px solid #fff;
      }
      
      #custom-notification.success {
        background: linear-gradient(135deg, #28a745, #20c997);
        border-left: 5px solid #fff;
      }
      
      #custom-notification.warning {
        background: linear-gradient(135deg, #ffc107, #fd7e14);
        border-left: 5px solid #fff;
      }
      
      #custom-notification.error {
        background: linear-gradient(135deg, #dc3545, #c82333);
        border-left: 5px solid #fff;
      }
      
      @keyframes slideIn {
        from { transform: translateX(120%); }
        to { transform: translateX(0); }
      }
      
      @keyframes slideOut {
        from { transform: translateX(0); }
        to { transform: translateX(120%); }
      }
    `;
    document.head.appendChild(style);
  }
  
  // Déterminer l'icône et le titre selon le type
  let icon = 'fa-info-circle';
  let title = 'Information';
  
  switch(type) {
    case 'success':
      icon = 'fa-check-circle';
      title = 'Succès';
      break;
    case 'warning':
      icon = 'fa-exclamation-triangle';
      title = 'Attention';
      break;
    case 'error':
      icon = 'fa-times-circle';
      title = 'Erreur';
      break;
    default:
      icon = 'fa-info-circle';
      title = 'Information';
  }
  
  // Construire le contenu
  notification.className = `show ${type}`;
  notification.innerHTML = `
    <i class="fas ${icon}"></i>
    <div class="notification-content">
      <div class="notification-title">${title}</div>
      <div class="notification-message">${message}</div>
    </div>
    <button class="close-btn" onclick="hideNotification()">&times;</button>
  `;
  
  // Cacher la notification précédente si elle existe
  if (notification.timeoutId) {
    clearTimeout(notification.timeoutId);
  }
  
  // Afficher
  notification.style.display = 'flex';
  
  // Auto-cacher après duration
  notification.timeoutId = setTimeout(() => {
    hideNotification();
  }, duration);
}

// ==================== CACHER LA NOTIFICATION ====================
function hideNotification() {
  const notification = document.getElementById('custom-notification');
  if (notification) {
    notification.classList.remove('show');
    if (notification.timeoutId) {
      clearTimeout(notification.timeoutId);
    }
    setTimeout(() => {
      notification.style.display = 'none';
    }, 300);
  }
}

// ==================== FONCTIONS SPÉCIFIQUES POUR VOS BESOINS ====================
function notifySuccess(message) {
  showNotification(message, 'success', 3000);
}

function notifyError(message) {
  showNotification(message, 'error', 4000);
}

function notifyWarning(message) {
  showNotification(message, 'warning', 3500);
}

function notifyInfo(message) {
  showNotification(message, 'info', 3000);
}

  </script>
</body>
</html>