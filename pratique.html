<!DOCTYPE html>
<html lang="fr">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ArduinoLearn - Bac à Sable Pratique</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    :root {
      --primary-color: #00979c;
      --secondary-color: #00696b;
      --accent-color: #ff9800;
      --light-color: #f8f9fa;
      --dark-color: #333;
      --gray-color: #6c757d;
      --success-color: #28a745;
      --danger-color: #dc3545;
      --warning-color: #ffc107;
      --info-color: #17a2b8;
      --code-editor-bg: #1e1e1e;
      --code-text-color: #d4d4d4;
      --serial-bg: #000;
      --serial-text: #00ff00;
      --esp32-blue: #1e3799;
      --esp32-dark: #0c2461;
      --card-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
      --hover-shadow: 0 15px 40px rgba(0, 0, 0, 0.15);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    body {
      background-color: #f5f7fa;
      color: var(--dark-color);
      line-height: 1.6;
      min-height: 100vh;
      overflow-x: hidden;
    }

    .container {
      width: 100%;
      max-width: 1400px;
      margin: 0 auto;
      padding: 0 20px;
    }

    /* Header Styles */
    header {
      background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
      color: white;
      padding: 1rem 0;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
      position: sticky;
      top: 0;
      z-index: 1000;
    }

    .header-content {
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
    }

    .logo {
      font-size: 1.8rem;
      font-weight: 800;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .logo i {
      color: var(--accent-color);
      font-size: 2rem;
    }

    .logo span {
      color: var(--accent-color);
    }

    nav ul {
      display: flex;
      list-style: none;
      gap: 1.5rem;
      align-items: center;
    }

    nav ul li a {
      color: white;
      text-decoration: none;
      font-weight: 600;
      transition: all 0.3s ease;
      padding: 10px 18px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 1rem;
    }

    nav ul li a:hover {
      background: rgba(255, 255, 255, 0.15);
      transform: translateY(-2px);
    }

    nav ul li a.active {
      background: rgba(255, 255, 255, 0.25);
      color: var(--accent-color);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    }

    nav ul li a i {
      font-size: 1.1rem;
    }

    /* Hero Section */
    .hero {
      background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
      color: white;
      padding: 3rem 0;
      text-align: center;
      margin-bottom: 2rem;
      border-radius: 0 0 20px 20px;
    }

    .hero h1 {
      font-size: 2.5rem;
      margin-bottom: 1rem;
      font-weight: 800;
    }

    .hero p {
      font-size: 1.2rem;
      max-width: 800px;
      margin: 0 auto 1.5rem;
      opacity: 0.95;
      line-height: 1.6;
    }

    .hero-features {
      display: flex;
      gap: 1.5rem;
      justify-content: center;
      margin-top: 2rem;
      flex-wrap: wrap;
    }

    .hero-feature {
      background: rgba(255, 255, 255, 0.15);
      padding: 1rem 1.8rem;
      border-radius: 12px;
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 1rem;
      border: 1px solid rgba(255, 255, 255, 0.2);
      transition: all 0.3s ease;
    }

    .hero-feature:hover {
      background: rgba(255, 255, 255, 0.25);
      transform: translateY(-5px);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
    }

    .hero-feature i {
      font-size: 1.4rem;
      color: var(--accent-color);
    }

    /* Code Template Section */
    .code-template {
      background: white;
      padding: 2rem;
      border-radius: 15px;
      margin-bottom: 2rem;
      box-shadow: var(--card-shadow);
      border-left: 6px solid var(--primary-color);
    }

    .template-title {
      color: var(--primary-color);
      margin-bottom: 1.2rem;
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 1.5rem;
      font-weight: 700;
    }

    .template-title i {
      font-size: 1.6rem;
    }

    .code-template p {
      color: var(--secondary-color);
      margin-bottom: 1.5rem;
      font-size: 1.1rem;
      line-height: 1.6;
    }

    .template-buttons {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
      margin-top: 1.5rem;
    }

    .template-btn {
      padding: 1rem 1.8rem;
      background: white;
      border: 2px solid var(--primary-color);
      border-radius: 10px;
      cursor: pointer;
      font-weight: 600;
      color: var(--primary-color);
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 1rem;
      box-shadow: 0 4px 15px rgba(0, 151, 156, 0.1);
    }

    .template-btn:hover {
      background: var(--primary-color);
      color: white;
      transform: translateY(-3px);
      box-shadow: 0 8px 25px rgba(0, 151, 156, 0.25);
    }

    .template-btn i {
      font-size: 1.2rem;
    }

    /* Main Layout Grid */
    .main-layout {
      display: grid;
      grid-template-columns: 1fr;
      gap: 2rem;
      margin-bottom: 3rem;
    }

    .main-section {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 2rem;
      height: 650px;
    }

    @media (max-width: 1200px) {
      .main-section {
        grid-template-columns: 1fr;
        height: auto;
      }
    }

    /* Code Panel */
    .code-panel {
      background: white;
      border-radius: 15px;
      padding: 1.5rem;
      box-shadow: var(--card-shadow);
      display: flex;
      flex-direction: column;
      height: 100%;
      overflow: hidden;
      border: 1px solid rgba(0, 0, 0, 0.08);
      position: relative;
    }

    .code-panel::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 5px;
      background: linear-gradient(90deg, var(--primary-color), var(--accent-color));
      border-radius: 15px 15px 0 0;
    }

    .panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1.5rem;
      padding-bottom: 1.2rem;
      border-bottom: 2px solid #eee;
      flex-wrap: wrap;
      gap: 1.5rem;
    }

    .panel-title {
      color: var(--primary-color);
      font-size: 1.5rem;
      display: flex;
      align-items: center;
      gap: 10px;
      font-weight: 700;
    }

    .panel-title i {
      font-size: 1.8rem;
      color: var(--accent-color);
    }

    .panel-actions {
      display: flex;
      gap: 0.8rem;
      flex-wrap: wrap;
    }

    /* Code Editor */
    .code-editor {
      flex: 1;
      background: var(--code-editor-bg);
      border-radius: 12px;
      overflow: hidden;
      border: 2px solid #2d2d2d;
      display: flex;
      flex-direction: column;
      min-height: 300px;
    }

    .editor-header {
      background: #2d2d2d;
      padding: 0.8rem 1.5rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 2px solid #1a1a1a;
    }

    .editor-dots {
      display: flex;
      gap: 8px;
    }

    .editor-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
    }

    .editor-dot.red {
      background: linear-gradient(135deg, #ff5f56, #ff2e23);
    }

    .editor-dot.yellow {
      background: linear-gradient(135deg, #ffbd2e, #ffa500);
    }

    .editor-dot.green {
      background: linear-gradient(135deg, #27ca3f, #1db334);
    }

    .editor-filename {
      color: #aaa;
      font-family: 'Consolas', 'Monaco', monospace;
      font-size: 1rem;
      font-weight: 500;
    }

    .editor-content {
      flex: 1;
      padding: 1.5rem;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 1rem;
      line-height: 1.5;
      color: var(--code-text-color);
      tab-size: 4;
      overflow-y: auto;
      background: var(--code-editor-bg);
    }

    .editor-content::-webkit-scrollbar {
      width: 10px;
    }

    .editor-content::-webkit-scrollbar-track {
      background: #1a1a1a;
      border-radius: 5px;
    }

    .editor-content::-webkit-scrollbar-thumb {
      background: #444;
      border-radius: 5px;
      border: 2px solid #1a1a1a;
    }

    .code-line {
      padding: 4px 0;
      min-height: 28px;
      position: relative;
      display: flex;
      align-items: center;
      margin-bottom: 2px;
    }

    .line-number {
      width: 50px;
      color: #6a6a6a;
      text-align: right;
      padding-right: 15px;
      user-select: none;
      font-size: 1rem;
      flex-shrink: 0;
      font-weight: 400;
    }

    .code-input {
      background: transparent;
      border: none;
      outline: none;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 1rem;
      color: var(--code-text-color);
      flex: 1;
      padding: 0 15px;
      min-height: 28px;
      resize: none;
      overflow: hidden;
      line-height: 1.5;
      white-space: pre;
      overflow-x: auto;
    }

    .code-input:focus {
      background-color: rgba(255, 255, 255, 0.08);
      border-radius: 4px;
    }

    .code-input::-webkit-scrollbar {
      height: 4px;
    }

    .code-input::-webkit-scrollbar-track {
      background: transparent;
    }

    .code-input::-webkit-scrollbar-thumb {
      background: #666;
      border-radius: 2px;
    }

    /* Simulation Panel */
    .simulation-panel {
      background: white;
      border-radius: 15px;
      padding: 1.5rem;
      box-shadow: var(--card-shadow);
      display: flex;
      flex-direction: column;
      height: 100%;
      overflow: hidden;
      border: 1px solid rgba(0, 0, 0, 0.08);
      position: relative;
    }

    .simulation-panel::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 5px;
      background: linear-gradient(90deg, var(--accent-color), var(--primary-color));
      border-radius: 15px 15px 0 0;
    }

    /* Simulation Content Layout */
    .simulation-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
      overflow-y: auto;
      padding-right: 5px;
    }

    .simulation-content::-webkit-scrollbar {
      width: 8px;
    }

    .simulation-content::-webkit-scrollbar-track {
      background: #f1f1f1;
      border-radius: 4px;
    }

    .simulation-content::-webkit-scrollbar-thumb {
      background: var(--primary-color);
      border-radius: 4px;
    }

    /* ESP32 Board */
    .esp32-board {
      width: 100%;
      height: 200px;
      background: linear-gradient(145deg, var(--esp32-dark), var(--esp32-blue));
      border-radius: 15px;
      position: relative;
      box-shadow: 
        0 8px 25px rgba(0, 0, 0, 0.3),
        inset 0 2px 10px rgba(255, 255, 255, 0.1);
      border: 3px solid #09183d;
      overflow: hidden;
    }

    .esp32-chip {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 180px;
      height: 120px;
      background: linear-gradient(145deg, #0a0a0a, #222);
      border-radius: 12px;
      color: white;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 1.8rem;
      font-weight: 900;
      box-shadow: 
        0 6px 20px rgba(0, 0, 0, 0.8),
        inset 0 2px 8px rgba(255, 255, 255, 0.1);
      border: 3px solid #333;
      letter-spacing: 1px;
    }

    .esp32-antenna {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: radial-gradient(circle at 35% 35%, #444, #111);
      display: flex;
      justify-content: center;
      align-items: center;
      color: #ffd32a;
      box-shadow: 
        0 4px 15px rgba(255, 211, 42, 0.6),
        inset 0 2px 8px rgba(255, 255, 255, 0.2);
      border: 2px solid #555;
    }

    .esp32-antenna i {
      font-size: 1.5rem;
    }

    /* ESP32 Pins */
    .esp32-pins {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 40px;
      display: flex;
      justify-content: space-around;
      padding: 0 10px;
    }

    .pin {
      width: 20px;
      height: 30px;
      background: linear-gradient(to bottom, #d1d8e0, #a5b1c2);
      border-radius: 3px;
      position: relative;
      margin-top: 10px;
      transition: all 0.3s ease;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    }

    .pin.active {
      background: linear-gradient(to bottom, #ffd32a, #ffa801);
      box-shadow: 0 0 15px rgba(255, 211, 42, 0.7);
    }

    .pin-label {
      position: absolute;
      top: -20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.7rem;
      color: white;
      font-weight: bold;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
      white-space: nowrap;
    }

    /* GPIO Visualization */
    .gpio-status {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      gap: 1rem;
      margin-top: 1rem;
    }

    .gpio-item {
      background: white;
      border-radius: 8px;
      padding: 1rem;
      border: 2px solid #e0e0e0;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .gpio-item.active {
      border-color: var(--primary-color);
      box-shadow: 0 5px 15px rgba(0, 151, 156, 0.2);
    }

    .gpio-item.output-high {
      background: linear-gradient(135deg, #4CAF50, #2E7D32);
      color: white;
    }

    .gpio-item.output-low {
      background: linear-gradient(135deg, #f8f9fa, #e9ecef);
    }

    .gpio-item.pwm {
      border-color: #FF9800;
      background: linear-gradient(135deg, #fff3e0, #ffe0b2);
      animation: pwmPulse 2s infinite;
    }

    @keyframes pwmPulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    .gpio-label {
      font-weight: 700;
      font-size: 1rem;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .gpio-label i {
      font-size: 0.9rem;
    }

    .gpio-value {
      font-size: 0.9rem;
      font-family: 'Consolas', monospace;
      padding: 4px 8px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 4px;
      text-align: center;
    }

    /* Configuration Section */
    .config-section {
      background: linear-gradient(135deg, #f8f9fa, #e9ecef);
      border-radius: 12px;
      padding: 1.5rem;
      border: 2px solid #dee2e6;
      box-shadow: 
        inset 0 2px 8px rgba(0, 0, 0, 0.05),
        0 4px 15px rgba(0, 0, 0, 0.05);
    }

    .config-title {
      color: var(--secondary-color);
      margin-bottom: 1rem;
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 1.2rem;
      font-weight: 700;
    }

    .config-title i {
      color: var(--accent-color);
      font-size: 1.3rem;
    }

    .config-section p {
      color: var(--gray-color);
      margin-bottom: 1rem;
      font-size: 1rem;
      line-height: 1.5;
    }

    /* Controls Section */
    .controls-section {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1.5rem;
      margin-top: 2rem;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .control-btn {
      padding: 1rem 1.5rem;
      background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
      color: white;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 700;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
      font-size: 1rem;
      box-shadow: 0 5px 20px rgba(0, 151, 156, 0.25);
    }

    .control-btn:hover {
      transform: translateY(-5px);
      box-shadow: 0 10px 30px rgba(0, 151, 156, 0.35);
    }

    .control-btn i {
      font-size: 1.2rem;
    }

    .control-btn.run {
      background: linear-gradient(135deg, var(--success-color), #1e7e34);
      box-shadow: 0 5px 20px rgba(40, 167, 69, 0.25);
    }

    .control-btn.reset {
      background: linear-gradient(135deg, var(--gray-color), #495057);
      box-shadow: 0 5px 20px rgba(108, 117, 125, 0.25);
    }

    /* Serial Monitor */
    .serial-monitor {
      background: var(--serial-bg);
      color: var(--serial-text);
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      padding: 1.5rem;
      border-radius: 12px;
      height: 200px;
      overflow-y: auto;
      border: 3px solid #222;
      box-shadow: 
        inset 0 0 20px rgba(0, 255, 0, 0.1),
        0 5px 20px rgba(0, 0, 0, 0.3);
    }

    .serial-monitor::-webkit-scrollbar {
      width: 10px;
    }

    .serial-monitor::-webkit-scrollbar-track {
      background: #111;
      border-radius: 5px;
    }

    .serial-monitor::-webkit-scrollbar-thumb {
      background: var(--serial-text);
      border-radius: 5px;
      border: 2px solid #111;
    }

    .serial-line {
      margin-bottom: 0.8rem;
      font-size: 0.9rem;
      line-height: 1.4;
      padding-left: 12px;
      border-left: 3px solid var(--serial-text);
    }

    .serial-line.error {
      color: #ff6b6b;
      border-left-color: #ff6b6b;
    }

    .serial-line.info {
      color: #4dabf7;
      border-left-color: #4dabf7;
    }

    .serial-line.success {
      color: #69db7c;
      border-left-color: #69db7c;
    }

    /* Compilation Block */
    .compilation-block {
      background: #2d2d2d;
      border-radius: 8px;
      padding: 1rem;
      margin: 1rem 0;
      color: #d4d4d4;
      font-family: 'Consolas', monospace;
      font-size: 0.9rem;
      min-height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 1px solid #444;
    }

    .compilation-success {
      color: #69db7c;
      font-weight: bold;
    }

    .compilation-error {
      color: #ff6b6b;
      font-weight: bold;
    }

    /* Footer */
    footer {
      background: linear-gradient(135deg, var(--secondary-color), #004d4d);
      color: white;
      padding: 2rem 0;
      margin-top: 3rem;
    }

    .footer-content {
      text-align: center;
    }

    .footer-content p {
      margin-bottom: 1rem;
      font-size: 1.2rem;
      font-weight: 700;
    }

    .footer-info {
      opacity: 0.9;
      margin-top: 1rem;
      font-size: 1rem;
      max-width: 800px;
      margin: 1rem auto 0;
      line-height: 1.6;
    }

    /* Status indicators */
    .status-indicator {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-right: 8px;
    }

    .status-running {
      background-color: var(--success-color);
      animation: pulse 1s infinite;
    }

    .status-stopped {
      background-color: var(--danger-color);
    }

    .status-ready {
      background-color: var(--accent-color);
    }

    /* Responsive Design */
    @media (max-width: 992px) {
      .main-section {
        height: auto;
        gap: 1.5rem;
      }
      
      .code-panel, .simulation-panel {
        height: 600px;
      }
      
      .gpio-status {
        grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
      }
      
      .esp32-board {
        height: 180px;
      }
      
      .esp32-chip {
        width: 150px;
        height: 100px;
        font-size: 1.5rem;
      }
    }

    @media (max-width: 768px) {
      .header-content {
        flex-direction: column;
        text-align: center;
        gap: 1.5rem;
      }
      
      nav ul {
        justify-content: center;
        flex-wrap: wrap;
        gap: 1rem;
      }
      
      nav ul li a {
        padding: 8px 14px;
        font-size: 0.9rem;
      }
      
      .hero {
        padding: 2rem 0;
      }
      
      .hero h1 {
        font-size: 2rem;
      }
      
      .hero p {
        font-size: 1.1rem;
      }
      
      .hero-features {
        flex-direction: column;
        align-items: center;
        gap: 1rem;
      }
      
      .hero-feature {
        width: 100%;
        max-width: 350px;
        justify-content: center;
      }
      
      .panel-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 1rem;
      }
      
      .panel-actions {
        width: 100%;
        justify-content: center;
      }
      
      .template-buttons {
        justify-content: center;
      }
      
      .controls-section {
        grid-template-columns: 1fr;
      }
      
      .code-panel, .simulation-panel {
        height: 500px;
      }
      
      .gpio-status {
        grid-template-columns: repeat(3, 1fr);
      }
    }

    @media (max-width: 576px) {
      .container {
        padding: 0 15px;
      }
      
      .code-panel, .simulation-panel {
        padding: 1.2rem;
      }
      
      .panel-title {
        font-size: 1.3rem;
      }
      
      .editor-content {
        padding: 1.2rem;
      }
      
      .gpio-status {
        grid-template-columns: repeat(2, 1fr);
      }
      
      .hero h1 {
        font-size: 1.8rem;
      }
      
      .hero p {
        font-size: 1rem;
      }
      
      .logo {
        font-size: 1.5rem;
      }
      
      .esp32-board {
        height: 150px;
      }
      
      .esp32-chip {
        width: 120px;
        height: 80px;
        font-size: 1.3rem;
      }
    }

    /* Animations */
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .fade-in {
      animation: fadeIn 0.6s ease-out;
    }

    @keyframes pulse {
      0% { opacity: 0.6; }
      50% { opacity: 1; }
      100% { opacity: 0.6; }
    }

    .pulse {
      animation: pulse 2s infinite;
    }

    /* Utility Classes */
    .text-center { text-align: center; }
    .mt-1 { margin-top: 0.5rem; }
    .mt-2 { margin-top: 1rem; }
    .mt-3 { margin-top: 1.5rem; }
    .mb-1 { margin-bottom: 0.5rem; }
    .mb-2 { margin-bottom: 1rem; }
    .mb-3 { margin-bottom: 1.5rem; }
  </style>
</head>

<body>
  <!-- Header -->
  <header>
    <div class="container header-content">
      <div class="logo">
        <i class="fas fa-microchip"></i>
        <div>Arduino/ESP<span>Learn</span></div>
      </div>
      <nav>
        <ul>
          <li><a href="index.html"><i class="fas fa-home"></i> Accueil</a></li>
          <li><a href="./pratique.html" class="active"><i class="fas fa-flask"></i> Pratique</a></li>
          <li><a href="./exemple.html"><i class="fas fa-code"></i> Exemples</a></li>
          <li><a href="#references"><i class="fas fa-book"></i> Référence</a></li>
          <li><a href="./exercice.html"><i class="fas fa-pencil-alt"></i> Exercices</a></li>
        </ul>
      </nav>
    </div>
  </header>

  <!-- Hero Section -->
  <section class="hero">
    <div class="container">
      <h1>Bac à Sable Arduino/ESP32</h1>
      <p>Créez, testez et visualisez vos projets Arduino/ESP32 en temps réel dans ce simulateur interactif</p>
      <div class="hero-features">
        <div class="hero-feature">
          <i class="fas fa-bolt"></i>Simulation en direct
        </div>
        <div class="hero-feature">
          <i class="fas fa-cogs"></i>Broches configurables
        </div>
        <div class="hero-feature">
          <i class="fas fa-code"></i>Interpréteur Arduino
        </div>
      </div>
    </div>
  </section>

  <!-- Main Content -->
  <div class="container">
    <!-- Code Templates -->
    <div class="code-template fade-in">
      <h3 class="template-title"><i class="fas fa-magic"></i> Templates de code</h3>
      <p>Commencez avec un modèle prédéfini ou créez votre propre code de zéro :</p>
      <div class="template-buttons">
        <button class="template-btn" onclick="loadTemplate('blink')">
          <i class="fas fa-lightbulb"></i> LED Clignotante
        </button>
        <button class="template-btn" onclick="loadTemplate('chase')">
          <i class="fas fa-running"></i> LEDs Chassées
        </button>
        <button class="template-btn" onclick="loadTemplate('pwm')">
          <i class="fas fa-wave-square"></i> Effet PWM
        </button>
        <button class="template-btn" onclick="loadTemplate('rgb')">
          <i class="fas fa-palette"></i> LED RGB
        </button>
        <button class="template-btn" onclick="loadTemplate('empty')">
          <i class="fas fa-file"></i> Nouveau Fichier
        </button>
      </div>
    </div>

    <!-- Main Layout -->
    <div class="main-layout">
      <!-- Main Section with Two Columns -->
      <div class="main-section">
        <!-- Code Panel -->
        <div class="code-panel fade-in">
          <div class="panel-header">
            <h2 class="panel-title"><i class="fas fa-code"></i> Éditeur de Code</h2>
            <div class="panel-actions">
              <button class="template-btn" onclick="formatCode()">
                <i class="fas fa-align-left"></i> Formater
              </button>
              <button class="template-btn" onclick="clearCode()">
                <i class="fas fa-trash"></i> Effacer
              </button>
            </div>
          </div>

          <div class="code-editor">
            <div class="editor-header">
              <div class="editor-dots">
                <div class="editor-dot red"></div>
                <div class="editor-dot yellow"></div>
                <div class="editor-dot green"></div>
              </div>
              <div class="editor-filename">projet.ino</div>
            </div>
            <div class="editor-content" id="editor-content">
              <!-- Code lines will be generated here -->
            </div>
          </div>
        </div>

        <!-- Simulation Panel -->
        <div class="simulation-panel fade-in">
          <div class="panel-header">
            <h2 class="panel-title">
              <i class="fas fa-microchip"></i> Simulation ESP32
              <span class="status-indicator status-ready" id="simulation-status"></span>
            </h2>
            <div class="panel-actions">
              <button class="template-btn" onclick="exportCode()">
                <i class="fas fa-download"></i> Exporter
              </button>
              <button class="template-btn" onclick="document.getElementById('import-file').click()">
                <i class="fas fa-upload"></i> Importer
              </button>
            </div>
          </div>

          <div class="simulation-content">
            <!-- ESP32 Board -->
            <div class="esp32-board">
              <div class="esp32-chip">ESP32</div>
              <div class="esp32-antenna">
                <i class="fas fa-wifi"></i>
              </div>
              <div class="esp32-pins" id="esp32-pins">
                <!-- Pins will be generated dynamically -->
              </div>
            </div>

            <!-- Compilation Block -->
            <div class="compilation-block" id="compilation-block">
              <div id="compilation-message">Prêt à compiler...</div>
            </div>

            <!-- GPIO Status -->
            <div class="config-section">
              <h3 class="config-title"><i class="fas fa-cog"></i> État des Broches GPIO</h3>
              <p>Les broches utilisées dans votre code apparaissent ici :</p>
              <div class="gpio-status" id="gpio-status">
                <!-- GPIO items will be generated dynamically -->
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Controls Section -->
      <div class="controls-section fade-in">
        <div class="control-group">
          <button class="control-btn run" onclick="runCode()" id="run-button">
            <i class="fas fa-play"></i> Compiler & Exécuter
          </button>
          <p class="text-center mt-1">Compile et exécute votre code Arduino</p>
        </div>
        
        <div class="control-group">
          <button class="control-btn reset" onclick="resetSimulation()">
            <i class="fas fa-redo"></i> Réinitialiser
          </button>
          <p class="text-center mt-1">Remet la simulation à zéro</p>
        </div>
      </div>
      
      <!-- Serial Monitor -->
      <div class="serial-monitor" id="serial-monitor">
        <div class="serial-line">Bac à sable Arduino/ESP32 initialisé</div>
        <div class="serial-line">Prêt à exécuter du code...</div>
      </div>
    </div>
  </div>

  <!-- Import file input (hidden) -->
  <input type="file" id="import-file" accept=".ino,.txt" style="display: none;">

  <script>
    // Arduino Simulator Engine
    class ArduinoSimulator {
      constructor() {
        this.pins = {};
        this.variables = {};
        this.serialBuffer = [];
        this.isRunning = false;
        this.loopInterval = null;
        this.delayQueue = [];
        this.pinCallbacks = {};
        this.setupExecuted = false;
        this.lastLoopTime = 0;
        
        // Initialize all pins
        this.initializePins();
        
        // Initialize built-in functions
        this.initializeBuiltins();
      }

      initializePins() {
        // Initialize 20 GPIO pins (0-19)
        for (let i = 0; i < 20; i++) {
          this.pins[i] = {
            mode: 'INPUT',
            value: 0,
            pwmValue: 0,
            pwm: false
          };
        }
      }

      initializeBuiltins() {
        // Constants
        this.variables.HIGH = 1;
        this.variables.LOW = 0;
        this.variables.OUTPUT = 'OUTPUT';
        this.variables.INPUT = 'INPUT';
        this.variables.INPUT_PULLUP = 'INPUT_PULLUP';
        this.variables.LED_BUILTIN = 2; // GPIO2 on ESP32
      }

      // Parse Arduino code
      parseCode(code) {
        const result = {
          setup: '',
          loop: '',
          variables: new Map(),
          pinModes: new Map(),
          digitalWrites: [],
          analogWrites: [],
          delays: [],
          serialPrints: []
        };

        const lines = code.split('\n');
        let inSetup = false;
        let inLoop = false;
        let braceCount = 0;

        for (let line of lines) {
          const trimmed = line.trim();
          
          // Skip empty lines and comments
          if (!trimmed || trimmed.startsWith('//')) continue;

          // Detect setup function
          if (trimmed.includes('void setup()')) {
            inSetup = true;
            inLoop = false;
            continue;
          }

          // Detect loop function
          if (trimmed.includes('void loop()')) {
            inLoop = true;
            inSetup = false;
            continue;
          }

          // Track braces
          if (inSetup || inLoop) {
            braceCount += (trimmed.match(/{/g) || []).length;
            braceCount -= (trimmed.match(/}/g) || []).length;

            if (braceCount === 0 && (inSetup || inLoop)) {
              inSetup = false;
              inLoop = false;
            }
          }

          // Parse pinMode
          if (trimmed.includes('pinMode(')) {
            const match = trimmed.match(/pinMode\s*\(\s*(\d+|LED_BUILTIN)\s*,\s*(INPUT|OUTPUT|INPUT_PULLUP)\s*\)/);
            if (match) {
              const pin = match[1] === 'LED_BUILTIN' ? 2 : parseInt(match[1]);
              const mode = match[2];
              result.pinModes.set(pin, mode);
              
              if (inSetup) result.setup += line + '\n';
              if (inLoop) result.loop += line + '\n';
              continue;
            }
          }

          // Parse digitalWrite
          if (trimmed.includes('digitalWrite(')) {
            const match = trimmed.match(/digitalWrite\s*\(\s*(\d+|LED_BUILTIN)\s*,\s*(HIGH|LOW)\s*\)/);
            if (match) {
              const pin = match[1] === 'LED_BUILTIN' ? 2 : parseInt(match[1]);
              const value = match[2] === 'HIGH' ? 1 : 0;
              result.digitalWrites.push({ pin, value, line });
              
              if (inSetup) result.setup += line + '\n';
              if (inLoop) result.loop += line + '\n';
              continue;
            }
          }

          // Parse analogWrite
          if (trimmed.includes('analogWrite(')) {
            const match = trimmed.match(/analogWrite\s*\(\s*(\d+)\s*,\s*(\d+)\s*\)/);
            if (match) {
              const pin = parseInt(match[1]);
              const value = parseInt(match[2]);
              result.analogWrites.push({ pin, value, line });
              
              if (inSetup) result.setup += line + '\n';
              if (inLoop) result.loop += line + '\n';
              continue;
            }
          }

          // Parse delay
          if (trimmed.includes('delay(')) {
            const match = trimmed.match(/delay\s*\(\s*(\d+)\s*\)/);
            if (match) {
              const ms = parseInt(match[1]);
              result.delays.push({ ms, line });
              
              if (inSetup) result.setup += line + '\n';
              if (inLoop) result.loop += line + '\n';
              continue;
            }
          }

          // Parse Serial.println
          if (trimmed.includes('Serial.println(')) {
            const match = trimmed.match(/Serial\.println\s*\(\s*"([^"]+)"\s*\)/);
            if (match) {
              const message = match[1];
              result.serialPrints.push({ message, line });
              
              if (inSetup) result.setup += line + '\n';
              if (inLoop) result.loop += line + '\n';
              continue;
            }
          }

          // Parse variable declarations
          if (trimmed.match(/^(int|const int)\s+\w+\s*=\s*\d+/)) {
            const match = trimmed.match(/(int|const int)\s+(\w+)\s*=\s*(\d+)/);
            if (match) {
              const name = match[2];
              const value = parseInt(match[3]);
              result.variables.set(name, value);
              
              if (inSetup) result.setup += line + '\n';
              if (inLoop) result.loop += line + '\n';
              continue;
            }
          }

          // Add other lines as-is
          if (inSetup) result.setup += line + '\n';
          if (inLoop) result.loop += line + '\n';
        }

        return result;
      }

      // Execute parsed code
      async execute(parsedCode) {
        this.stop();
        this.isRunning = true;
        this.setupExecuted = false;
        this.serialBuffer = [];

        try {
          // Execute setup
          await this.executeSetup(parsedCode);
          
          // Start loop execution
          this.startLoop(parsedCode);
          
          return true;
        } catch (error) {
          this.logError(`Erreur d'exécution: ${error.message}`);
          return false;
        }
      }

      async executeSetup(parsedCode) {
        if (this.setupExecuted) return;
        
        // Apply pin modes
        for (const [pin, mode] of parsedCode.pinModes) {
          this.pins[pin].mode = mode;
          this.triggerPinChange(pin, mode, 0);
        }

        // Execute digitalWrites in setup
        for (const dw of parsedCode.digitalWrites) {
          if (dw.line.includes('setup')) {
            this.pins[dw.pin].value = dw.value;
            this.triggerPinChange(dw.pin, 'OUTPUT', dw.value);
          }
        }

        // Execute analogWrites in setup
        for (const aw of parsedCode.analogWrites) {
          if (aw.line.includes('setup')) {
            this.pins[aw.pin].pwm = true;
            this.pins[aw.pin].pwmValue = aw.value;
            this.triggerPinChange(aw.pin, 'PWM', aw.value);
          }
        }

        // Execute Serial.println in setup
        for (const sp of parsedCode.serialPrints) {
          if (sp.line.includes('setup')) {
            this.serialBuffer.push(sp.message);
          }
        }

        this.setupExecuted = true;
        this.logInfo('Setup() exécuté avec succès');
      }

      startLoop(parsedCode) {
        if (!this.setupExecuted) {
          this.executeSetup(parsedCode);
        }

        let loopCycle = 0;
        const executeLoopCycle = async () => {
          if (!this.isRunning) return;

          // Execute digitalWrites in loop
          for (const dw of parsedCode.digitalWrites) {
            if (dw.line.includes('loop')) {
              this.pins[dw.pin].value = dw.value;
              this.triggerPinChange(dw.pin, 'OUTPUT', dw.value);
              
              // Log to serial
              const state = dw.value === 1 ? 'HIGH' : 'LOW';
              this.serialBuffer.push(`digitalWrite(${dw.pin}, ${state})`);
            }
          }

          // Execute analogWrites in loop
          for (const aw of parsedCode.analogWrites) {
            if (aw.line.includes('loop')) {
              this.pins[aw.pin].pwm = true;
              this.pins[aw.pin].pwmValue = aw.value;
              this.triggerPinChange(aw.pin, 'PWM', aw.value);
              
              // Log to serial
              this.serialBuffer.push(`analogWrite(${aw.pin}, ${aw.value})`);
            }
          }

          // Execute delays in loop
          for (const delayObj of parsedCode.delays) {
            if (delayObj.line.includes('loop')) {
              this.serialBuffer.push(`delay(${delayObj.ms})`);
              await this.wait(delayObj.ms);
            }
          }

          // Execute Serial.println in loop
          for (const sp of parsedCode.serialPrints) {
            if (sp.line.includes('loop')) {
              this.serialBuffer.push(sp.message);
            }
          }

          loopCycle++;
          
          // Stop after 10 cycles for simulation
          if (loopCycle >= 10) {
            this.serialBuffer.push("Simulation terminée après 10 cycles");
            this.stop();
            return;
          }

          // Schedule next loop cycle
          if (this.isRunning) {
            this.loopInterval = setTimeout(executeLoopCycle, 100);
          }
        };

        executeLoopCycle();
      }

      async wait(ms) {
        return new Promise(resolve => {
          setTimeout(resolve, Math.min(ms, 1000));
        });
      }

      stop() {
        this.isRunning = false;
        if (this.loopInterval) {
          clearTimeout(this.loopInterval);
          this.loopInterval = null;
        }
        this.logInfo('Simulation arrêtée');
      }

      triggerPinChange(pin, mode, value) {
        if (this.pinCallbacks[pin]) {
          this.pinCallbacks[pin](pin, mode, value);
        }
      }

      onPinChange(pin, callback) {
        this.pinCallbacks[pin] = callback;
      }

      logInfo(message) {
        this.serialBuffer.push(`[INFO] ${message}`);
      }

      logError(message) {
        this.serialBuffer.push(`[ERREUR] ${message}`);
      }
    }

    // Global variables
    const simulator = new ArduinoSimulator();
    let simulationRunning = false;
    let currentSimulation = null;

    // Initialize page
    function initPage() {
      // Initialize ESP32 pins visualization
      initESP32Pins();
      
      // Load default template
      loadTemplate('blink');
      
      // Setup import file input
      document.getElementById('import-file').addEventListener('change', importCode);
      
      // Initialize simulation status
      updateSimulationStatus('ready');
      
      addSerialLine("Bac à sable Arduino/ESP32 initialisé", 'info');
      addSerialLine("Utilisez les templates ou écrivez votre propre code !", 'info');
    }

    // Initialize ESP32 pins visualization
    function initESP32Pins() {
      const pinsContainer = document.getElementById('esp32-pins');
      pinsContainer.innerHTML = '';
      
      // Create pins for GPIO 0-19
      for (let i = 0; i < 20; i++) {
        const pin = document.createElement('div');
        pin.className = 'pin';
        pin.id = `esp-pin-${i}`;
        
        const label = document.createElement('div');
        label.className = 'pin-label';
        label.textContent = i;
        
        pin.appendChild(label);
        pinsContainer.appendChild(pin);
        
        // Register callback for pin changes
        simulator.onPinChange(i, (pinNum, mode, value) => {
          updatePinVisualization(pinNum, mode, value);
        });
      }
    }

    // Update pin visualization
    function updatePinVisualization(pin, mode, value) {
      const pinElement = document.getElementById(`esp-pin-${pin}`);
      const gpioItem = document.getElementById(`gpio-item-${pin}`);
      
      if (!pinElement) return;
      
      // Update ESP32 pin
      pinElement.classList.remove('active');
      
      if (mode === 'OUTPUT' && value === 1) {
        pinElement.classList.add('active');
      } else if (mode === 'PWM' && value > 0) {
        pinElement.classList.add('active');
        // Set opacity based on PWM value
        const opacity = 0.3 + (value / 255) * 0.7;
        pinElement.style.opacity = opacity;
      }
      
      // Update GPIO status item
      if (gpioItem) {
        gpioItem.classList.remove('output-high', 'output-low', 'pwm', 'active');
        
        if (mode === 'OUTPUT') {
          if (value === 1) {
            gpioItem.classList.add('output-high', 'active');
          } else {
            gpioItem.classList.add('output-low');
          }
        } else if (mode === 'PWM') {
          gpioItem.classList.add('pwm', 'active');
          const valueSpan = gpioItem.querySelector('.gpio-value');
          if (valueSpan) {
            valueSpan.textContent = `PWM: ${value}`;
          }
        }
      } else if (mode !== 'INPUT') {
        // Create new GPIO item if it doesn't exist
        createGPIOItem(pin, mode, value);
      }
    }

    // Create GPIO status item
    function createGPIOItem(pin, mode, value) {
      const gpioStatus = document.getElementById('gpio-status');
      
      const gpioItem = document.createElement('div');
      gpioItem.className = 'gpio-item';
      gpioItem.id = `gpio-item-${pin}`;
      
      const gpioLabel = document.createElement('div');
      gpioLabel.className = 'gpio-label';
      gpioLabel.innerHTML = `<i class="fas fa-microchip"></i> GPIO${pin}`;
      
      const gpioValue = document.createElement('div');
      gpioValue.className = 'gpio-value';
      
      if (mode === 'OUTPUT') {
        gpioItem.classList.add('output-low');
        gpioValue.textContent = value === 1 ? 'HIGH' : 'LOW';
      } else if (mode === 'PWM') {
        gpioItem.classList.add('pwm');
        gpioValue.textContent = `PWM: ${value}`;
      } else {
        gpioValue.textContent = 'INPUT';
      }
      
      gpioItem.appendChild(gpioLabel);
      gpioItem.appendChild(gpioValue);
      gpioStatus.appendChild(gpioItem);
    }

    // Load code template
    function loadTemplate(templateName) {
      const templates = {
        blink: `void setup() {
  pinMode(LED_BUILTIN, OUTPUT);
  Serial.begin(9600);
  Serial.println("Programme LED clignotante demarre");
}

void loop() {
  digitalWrite(LED_BUILTIN, HIGH);
  Serial.println("LED allumee");
  delay(1000);
  
  digitalWrite(LED_BUILTIN, LOW);
  Serial.println("LED eteinte");
  delay(1000);
}`,
        chase: `const int leds[] = {2, 4, 5, 18};
const int numLeds = 4;

void setup() {
  for(int i = 0; i < numLeds; i++) {
    pinMode(leds[i], OUTPUT);
  }
  Serial.begin(9600);
  Serial.println("LEDs chassees demarre");
}

void loop() {
  for(int i = 0; i < numLeds; i++) {
    digitalWrite(leds[i], HIGH);
    delay(200);
    digitalWrite(leds[i], LOW);
  }
  delay(500);
}`,
        pwm: `const int ledPin = 15;
int brightness = 0;
int fadeAmount = 5;

void setup() {
  pinMode(ledPin, OUTPUT);
  Serial.begin(9600);
  Serial.println("Effet PWM demarre");
}

void loop() {
  analogWrite(ledPin, brightness);
  Serial.print("PWM: ");
  Serial.println(brightness);
  
  brightness = brightness + fadeAmount;
  
  if (brightness <= 0 || brightness >= 255) {
    fadeAmount = -fadeAmount;
  }
  
  delay(30);
}`,
        rgb: `const int redPin = 12;
const int greenPin = 13;
const int bluePin = 14;

void setup() {
  pinMode(redPin, OUTPUT);
  pinMode(greenPin, OUTPUT);
  pinMode(bluePin, OUTPUT);
  Serial.begin(9600);
  Serial.println("LED RGB demarre");
}

void setColor(int red, int green, int blue) {
  analogWrite(redPin, red);
  analogWrite(greenPin, green);
  analogWrite(bluePin, blue);
}

void loop() {
  setColor(255, 0, 0);
  Serial.println("Rouge");
  delay(1000);
  
  setColor(0, 255, 0);
  Serial.println("Vert");
  delay(1000);
  
  setColor(0, 0, 255);
  Serial.println("Bleu");
  delay(1000);
  
  setColor(255, 255, 0);
  Serial.println("Jaune");
  delay(1000);
  
  setColor(255, 0, 255);
  Serial.println("Magenta");
  delay(1000);
  
  setColor(0, 255, 255);
  Serial.println("Cyan");
  delay(1000);
}`,
        empty: `void setup() {
  // Configurez vos broches ici
}

void loop() {
  // Votre code principal ici
}`
      };
      
      if (templates[templateName]) {
        loadCode(templates[templateName]);
        addSerialLine(`Template "${templateName}" chargé`, 'info');
      }
    }

    // Load code into editor
    function loadCode(code) {
      const editorContent = document.getElementById('editor-content');
      const lines = code.split('\n');
      
      editorContent.innerHTML = '';
      lines.forEach((line, index) => {
        const lineDiv = document.createElement('div');
        lineDiv.className = 'code-line';
        
        const lineNumber = document.createElement('span');
        lineNumber.className = 'line-number';
        lineNumber.textContent = index + 1;
        
        const codeInput = document.createElement('textarea');
        codeInput.className = 'code-input';
        codeInput.value = line;
        codeInput.setAttribute('data-line', index);
        codeInput.setAttribute('rows', '1');
        
        // Auto-resize textarea
        codeInput.addEventListener('input', function() {
          this.style.height = 'auto';
          this.style.height = (this.scrollHeight) + 'px';
        });
        
        lineDiv.appendChild(lineNumber);
        lineDiv.appendChild(codeInput);
        editorContent.appendChild(lineDiv);
      });
      
      // Trigger resize for all textareas
      document.querySelectorAll('.code-input').forEach(textarea => {
        textarea.style.height = 'auto';
        textarea.style.height = (textarea.scrollHeight) + 'px';
      });
      
      // Add event listeners
      attachCodeInputListeners();
    }

    // Format code
    function formatCode() {
      addSerialLine("Formatage du code...", 'info');
      const codeInputs = document.querySelectorAll('.code-input');
      let indentLevel = 0;
      
      codeInputs.forEach(input => {
        const line = input.value.trim();
        
        if (line.includes('}')) indentLevel--;
        
        const indent = '  '.repeat(Math.max(0, indentLevel));
        if (line && !line.startsWith(indent)) {
          input.value = indent + line;
        }
        
        if (line.includes('{')) indentLevel++;
      });
      
      addSerialLine("Code formaté", 'info');
    }

    // Clear code
    function clearCode() {
      if (confirm("Voulez-vous vraiment effacer tout le code?")) {
        loadCode(`void setup() {
  // Configurez vos broches ici
}

void loop() {
  // Votre code principal ici
}`);
        addSerialLine("Code effacé", 'info');
      }
    }

    // Get current code
    function getCurrentCode() {
      const codeInputs = document.querySelectorAll('.code-input');
      return Array.from(codeInputs).map(input => input.value).join('\n');
    }

    // Run code
    async function runCode() {
      if (simulationRunning) {
        stopSimulation();
        return;
      }
      
      const code = getCurrentCode();
      
      if (!code.trim()) {
        addSerialLine("ERREUR: Le code est vide", 'error');
        return;
      }
      
      // Clear previous simulation
      resetVisualization();
      
      // Show compilation
      const compilationBlock = document.getElementById('compilation-block');
      const compilationMessage = document.getElementById('compilation-message');
      compilationMessage.innerHTML = '<span class="compilation-success">Compilation en cours...</span>';
      compilationBlock.style.display = 'flex';
      
      addSerialLine("=== Compilation et exécution ===", 'info');
      updateSimulationStatus('running');
      
      try {
        // Parse and validate code
        const parsedCode = simulator.parseCode(code);
        
        // Check for syntax errors
        let hasErrors = false;
        const errorLines = [];
        
        // Basic syntax check
        const lines = code.split('\n');
        lines.forEach((line, index) => {
          const trimmed = line.trim();
          if (trimmed && !trimmed.startsWith('//')) {
            // Check for missing semicolons (except for function definitions and control structures)
            if (!trimmed.endsWith(';') && 
                !trimmed.endsWith('{') && 
                !trimmed.endsWith('}') &&
                !trimmed.includes('void ') &&
                !trimmed.includes('if(') &&
                !trimmed.includes('for(') &&
                !trimmed.includes('while(') &&
                !trimmed.includes('#') &&
                trimmed.length > 0) {
              errorLines.push(index + 1);
              hasErrors = true;
            }
          }
        });
        
        if (hasErrors) {
          throw new Error(`Erreurs de syntaxe aux lignes: ${errorLines.join(', ')}`);
        }
        
        // Show compilation success
        compilationMessage.innerHTML = '<span class="compilation-success">✓ Compilation réussie!</span>';
        
        // Execute code
        simulationRunning = true;
        const success = await simulator.execute(parsedCode);
        
        if (success) {
          // Start monitoring serial output
          monitorSerialOutput();
        } else {
          updateSimulationStatus('stopped');
        }
      } catch (error) {
        compilationMessage.innerHTML = `<span class="compilation-error">✗ Erreur de compilation: ${error.message}</span>`;
        addSerialLine(`ERREUR: ${error.message}`, 'error');
        updateSimulationStatus('stopped');
      }
    }

    // Monitor serial output
    function monitorSerialOutput() {
      const checkSerial = () => {
        if (simulator.serialBuffer.length > 0) {
          simulator.serialBuffer.forEach(msg => {
            addSerialLine(msg, 'info');
          });
          simulator.serialBuffer = [];
        }
        
        if (simulationRunning) {
          setTimeout(checkSerial, 100);
        }
      };
      
      checkSerial();
    }

    // Stop simulation
    function stopSimulation() {
      simulator.stop();
      simulationRunning = false;
      updateSimulationStatus('stopped');
      addSerialLine("Exécution arrêtée", 'info');
    }

    // Reset simulation
    function resetSimulation() {
      stopSimulation();
      resetVisualization();
      
      // Clear serial monitor except first two lines
      const serialMonitor = document.getElementById('serial-monitor');
      while (serialMonitor.children.length > 2) {
        serialMonitor.removeChild(serialMonitor.lastChild);
      }
      
      // Clear compilation block
      const compilationBlock = document.getElementById('compilation-block');
      compilationBlock.style.display = 'none';
      
      addSerialLine("Simulation réinitialisée", 'info');
      updateSimulationStatus('ready');
    }

    // Reset visualization
    function resetVisualization() {
      // Reset pins
      document.querySelectorAll('.pin').forEach(pin => {
        pin.classList.remove('active');
        pin.style.opacity = '1';
      });
      
      // Reset GPIO status
      document.getElementById('gpio-status').innerHTML = '';
    }

    // Update simulation status
    function updateSimulationStatus(status) {
      const statusElement = document.getElementById('simulation-status');
      const runButton = document.getElementById('run-button');
      
      statusElement.className = 'status-indicator';
      
      if (status === 'running') {
        statusElement.classList.add('status-running');
        runButton.innerHTML = '<i class="fas fa-stop"></i> Arrêter';
        runButton.onclick = stopSimulation;
      } else if (status === 'stopped') {
        statusElement.classList.add('status-stopped');
        runButton.innerHTML = '<i class="fas fa-play"></i> Compiler & Exécuter';
        runButton.onclick = runCode;
      } else {
        statusElement.classList.add('status-ready');
        runButton.innerHTML = '<i class="fas fa-play"></i> Compiler & Exécuter';
        runButton.onclick = runCode;
      }
    }

    // Add line to serial monitor
    function addSerialLine(text, type = 'normal') {
      const serialMonitor = document.getElementById('serial-monitor');
      const line = document.createElement('div');
      line.className = `serial-line ${type}`;
      line.textContent = `> ${text}`;
      serialMonitor.appendChild(line);
      serialMonitor.scrollTop = serialMonitor.scrollHeight;
    }

    // Export code
    function exportCode() {
      const code = getCurrentCode();
      const blob = new Blob([code], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'arduino_sketch.ino';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      addSerialLine("Code exporté en tant que 'arduino_sketch.ino'", 'info');
    }

    // Import code
    function importCode(event) {
      const file = event.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = function(e) {
        loadCode(e.target.result);
        addSerialLine(`Code importé depuis '${file.name}'`, 'info');
      };
      reader.readAsText(file);
      
      // Reset file input
      event.target.value = '';
    }

    // Attach event listeners to code inputs
    function attachCodeInputListeners() {
      const codeInputs = document.querySelectorAll('.code-input');
      codeInputs.forEach(input => {
        input.addEventListener('keydown', handleCodeInputKeydown);
        input.addEventListener('input', handleCodeInputInput);
      });
    }

    // Handle keydown in code editor
    function handleCodeInputKeydown(e) {
      const textarea = e.target;
      const line = parseInt(textarea.getAttribute('data-line'));
      
      if (e.key === 'Tab') {
        e.preventDefault();
        const start = textarea.selectionStart;
        const end = textarea.selectionEnd;
        
        // Insert tab
        textarea.value = textarea.value.substring(0, start) + '  ' + textarea.value.substring(end);
        textarea.selectionStart = textarea.selectionEnd = start + 2;
        
        // Trigger input event for auto-resize
        const inputEvent = new Event('input', { bubbles: true });
        textarea.dispatchEvent(inputEvent);
      } else if (e.key === 'Enter') {
        e.preventDefault();
        
        // Get indentation from current line
        const currentValue = textarea.value;
        const match = currentValue.substring(0, textarea.selectionStart).match(/^(\s*)/);
        const indent = match ? match[1] : '';
        
        // Get text before and after cursor
        const cursorPos = textarea.selectionStart;
        const beforeCursor = currentValue.substring(0, cursorPos);
        const afterCursor = currentValue.substring(cursorPos);
        
        // Update current line
        textarea.value = beforeCursor;
        
        // Create new line with proper indentation
        const editorContent = document.getElementById('editor-content');
        const newLineDiv = document.createElement('div');
        newLineDiv.className = 'code-line';
        
        const newLineNumber = document.createElement('span');
        newLineNumber.className = 'line-number';
        
        const newCodeInput = document.createElement('textarea');
        newCodeInput.className = 'code-input';
        newCodeInput.value = indent + afterCursor;
        newCodeInput.setAttribute('data-line', line + 1);
        newCodeInput.setAttribute('rows', '1');
        
        // Auto-resize
        newCodeInput.addEventListener('input', function() {
          this.style.height = 'auto';
          this.style.height = (this.scrollHeight) + 'px';
        });
        
        newLineDiv.appendChild(newLineNumber);
        newLineDiv.appendChild(newCodeInput);
        
        // Insert new line after current one
        const currentLineDiv = textarea.parentElement;
        editorContent.insertBefore(newLineDiv, currentLineDiv.nextSibling);
        
        // Update all line numbers and data-line attributes
        updateLineNumbers();
        
        // Attach event listener to new input
        newCodeInput.addEventListener('keydown', handleCodeInputKeydown);
        newCodeInput.addEventListener('input', handleCodeInputInput);
        
        // Focus new line
        newCodeInput.focus();
        newCodeInput.selectionStart = newCodeInput.selectionEnd = indent.length;
        
        // Trigger resize
        newCodeInput.style.height = 'auto';
        newCodeInput.style.height = (newCodeInput.scrollHeight) + 'px';
        textarea.style.height = 'auto';
        textarea.style.height = (textarea.scrollHeight) + 'px';
      } else if (e.key === 'Backspace') {
        const cursorPos = textarea.selectionStart;
        const value = textarea.value;
        
        // If at beginning of line with no text before cursor
        if (cursorPos === 0 && line > 0) {
          e.preventDefault();
          
          const prevLine = document.querySelector(`.code-input[data-line="${line - 1}"]`);
          if (prevLine) {
            const prevValue = prevLine.value;
            const currentValue = textarea.value;
            
            // Merge with previous line
            prevLine.value = prevValue + currentValue;
            
            // Remove current line
            const currentLineDiv = textarea.parentElement;
            currentLineDiv.remove();
            
            // Update line numbers
            updateLineNumbers();
            
            // Focus previous line at the merged position
            prevLine.focus();
            prevLine.selectionStart = prevLine.selectionEnd = prevValue.length;
            
            // Trigger resize
            prevLine.style.height = 'auto';
            prevLine.style.height = (prevLine.scrollHeight) + 'px';
          }
        }
      }
    }

    // Handle input in code editor (for auto-resize)
    function handleCodeInputInput(e) {
      const textarea = e.target;
      textarea.style.height = 'auto';
      textarea.style.height = (textarea.scrollHeight) + 'px';
    }

    // Update line numbers
    function updateLineNumbers() {
      const allLines = document.querySelectorAll('.code-line');
      allLines.forEach((lineDiv, index) => {
        const lineNumber = lineDiv.querySelector('.line-number');
        const codeInput = lineDiv.querySelector('.code-input');
        
        if (lineNumber) lineNumber.textContent = index + 1;
        if (codeInput) codeInput.setAttribute('data-line', index);
      });
    }

    // Initialize page when DOM is loaded
    document.addEventListener('DOMContentLoaded', initPage);
  </script>

  <footer>
    <div class="container footer-content">
      <p>ArduinoLearn - Simulateur interactif ESP32/Arduino</p>
      <div class="footer-info">
        Ce simulateur permet de tester du code Arduino/ESP32 avec un interpréteur JavaScript.
        Les broches de l'ESP32 s'allument en fonction des commandes digitalWrite() et analogWrite().
      </div>
    </div>
  </footer>
</body>
</html>